<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NaKole</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            background: #1a1a2e;
            color: #fff;
            overflow-x: hidden;
        }

        /* YouTube video pozad√≠ */
        #youtube-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            pointer-events: none;
        }

        #youtube-background iframe {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100vw;
            height: 56.25vw;
            min-height: 100vh;
            min-width: 177.77vh;
            transform: translate(-50%, -50%);
        }

        /* Tmav√Ω overlay */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.15);
            z-index: -1;
        }

        /* Hlavn√≠ kontejner */
        .container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            pointer-events: none;
        }

        .container > * {
            pointer-events: auto;
        }

        /* Horn√≠ panel */
        .top-panel {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 20px;
            gap: 20px;
            flex-wrap: wrap;
        }

        /* Spodn√≠ graf */
        .bottom-panel {
            margin-top: auto;
            padding: 0;
        }

        .track-toggle {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 24px;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            color: #fff;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            z-index: 50;
            transition: all 0.3s ease;
        }

        .track-toggle:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        /* Karty */
        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card h2 {
            font-size: 0.9rem;
            margin-bottom: 12px;
            color: #00d4ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card.stats-card {
            padding: 12px;
        }

        .card.stats-card h2 {
            display: none;
        }

        .card.youtube-card {
            max-width: 400px;
        }

        .card.track-card {
            border-radius: 0;
            padding: 0;
            background: transparent;
            border: none;
            box-shadow: none;
            backdrop-filter: none;
        }

        /* YouTube input sekce */
        .youtube-input {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .youtube-input input {
            flex: 1;
            min-width: 200px;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            font-size: 1rem;
        }

        .youtube-input input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #1a1a2e;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.4);
        }

        .error-message {
            color: #ff6b6b;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        /* Stats grid */
        .stats-grid {
            display: flex;
            gap: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            min-width: 90px;
        }

        .stat-label {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            transition: all 0.3s ease;
        }

        .stat-value.rpm {
            color: #00d4ff;
        }

        .stat-value.incline {
            color: #ff9f43;
        }

        .stat-value.load {
            color: #ee5a24;
        }

        .stat-value.time {
            color: #a29bfe;
            font-size: 2rem;
        }

        .stat-value.animate {
            transform: scale(1.1);
        }

        /* Load controls */
        .load-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 6px;
        }

        .load-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .load-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .load-offset {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
            min-width: 30px;
            text-align: center;
        }

        /* Nastaven√≠ */
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 16px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-item label {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .setting-item input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
        }

        .setting-item select {
            padding: 10px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            font-size: 1rem;
        }

        .setting-item select option {
            background: #1a1a2e;
        }

        .custom-input {
            padding: 10px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            font-size: 1rem;
            width: 100%;
        }

        .value-adjuster {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .value-adjuster input[type="range"] {
            flex: 1;
        }

        .btn-sm {
            padding: 4px 10px;
            font-size: 1rem;
            min-width: 32px;
        }

        /* Canvas kontejner */
        .canvas-container {
            width: 100%;
            height: 25vh;
            min-height: 150px;
            position: relative;
            background: transparent;
        }

        .canvas-container canvas {
            width: 100%;
            height: 100%;
        }

        .track-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.5);
            padding: 6px 12px;
            border-radius: 20px;
        }

        .track-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .track-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .zoom-level {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.7);
            min-width: 40px;
            text-align: center;
        }

        /* Tlaƒç√≠tka akce */
        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 16px;
        }

        /* Video controls */
        .video-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }

        /* Settings toggle */
        .settings-toggle {
            position: fixed;
            bottom: 30vh;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            color: #fff;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .settings-toggle:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.1);
        }

        /* Settings backdrop */
        .settings-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 98;
        }

        /* Video modal */
        .video-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 400px;
            width: 90%;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            z-index: 99;
        }

        /* Settings panel */
        .settings-panel {
            position: fixed;
            bottom: 30vh;
            right: 80px;
            max-width: 350px;
            max-height: calc(70vh - 20px);
            overflow-y: auto;
            z-index: 99;
        }

        .youtube-card {
            z-index: 100;
            position: relative;
        }

        .settings-panel .card {
            max-height: none;
        }

        .settings-panel .settings-grid {
            grid-template-columns: 1fr;
        }

        /* Video history */
        .video-history {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .video-history h3 {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
        }

        .history-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 150px;
            overflow-y: auto;
        }

        .history-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .history-info {
            flex: 1;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .history-info:hover {
            color: #00d4ff;
        }

        .history-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 180px;
        }

        .history-meta {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .history-duration {
            color: #00d4ff;
            font-size: 0.75rem;
        }

        .history-count {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.75rem;
        }

        .history-delete {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.4);
            cursor: pointer;
            padding: 4px;
            font-size: 0.9rem;
        }

        .history-delete:hover {
            color: #ff6b6b;
        }

        /* Responzivita */
        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }

            .card {
                padding: 16px;
            }

            .stat-value {
                font-size: 2rem;
            }
        }

        /* Animace fade */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card {
            animation: fadeIn 0.5s ease forwards;
        }

        .card:nth-child(2) { animation-delay: 0.1s; }
        .card:nth-child(3) { animation-delay: 0.2s; }
        .card:nth-child(4) { animation-delay: 0.3s; }
    </style>
</head>
<body>
<div id="app">
    <!-- YouTube pozad√≠ -->
    <div id="youtube-background">
        <div :id="'player'"></div>
    </div>

    <!-- Overlay -->
    <div class="overlay"></div>

    <!-- Hlavn√≠ obsah -->
    <div class="container">
        <!-- Horn√≠ panel -->
        <div class="top-panel">
            <!-- Statistiky - lev√Ω horn√≠ roh -->
            <div class="card stats-card">
                <h2>üìä Aktu√°ln√≠ hodnoty</h2>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">ƒåas</div>
                        <div class="stat-value time">{{ formatTime(cursorIndex) }}</div>
                        <div class="stat-label">/ {{ formatTime(trackPoints.length) }}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Kadence</div>
                        <div class="stat-value rpm">{{ rpm }}</div>
                        <div class="stat-label">RPM</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Stoup√°n√≠</div>
                        <div class="stat-value incline">{{ incline > 0 ? '+' : '' }}{{ incline }}%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Z√°tƒõ≈æ</div>
                        <div class="stat-value load">{{ load }}</div>
                        <div class="load-controls">
                            <button class="load-btn" @click="decreaseLoad">‚àí</button>
                            <span class="load-offset">{{ loadOffset >= 0 ? '+' : '' }}{{ loadOffset }}</span>
                            <button class="load-btn" @click="increaseLoad">+</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Video controls - prav√Ω horn√≠ roh -->
            <div class="card youtube-card">
                <div class="video-controls">
                    <button class="btn btn-secondary" @click="seekBackward" v-if="videoId && playerReady">‚è™ -30s</button>
                    <button class="btn btn-success" @click="playVideo" v-if="!isPlaying">‚ñ∂ P≈ôehr√°t</button>
                    <button class="btn btn-secondary" @click="pauseVideo" v-if="isPlaying">‚è∏ Pauza</button>
                    <button class="btn btn-secondary" @click="seekForward" v-if="videoId && playerReady">+30s ‚è©</button>
                </div>
            </div>
        </div>

        <!-- Spodn√≠ panel - Graf tratƒõ -->
        <div class="bottom-panel" v-if="showTrack">
            <div class="card track-card">
                <div class="canvas-container">
                    <canvas ref="trackCanvas" @click="seekToPosition($event)" style="cursor: pointer;"></canvas>
                    <div class="track-controls">
                        <button class="track-btn" @click="scrollTrack(-1)">‚óÄ</button>
                        <button class="track-btn" @click="zoomOut">‚àí</button>
                        <span class="zoom-level">{{ Math.round(trackZoom * 100) }}%</span>
                        <button class="track-btn" @click="zoomIn">+</button>
                        <button class="track-btn" @click="scrollTrack(1)">‚ñ∂</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Toggle graf -->
        <button class="track-toggle" @click="showTrack = !showTrack">
            {{ showTrack ? '‚ñº' : '‚ñ≤' }}
        </button>
    </div>

    <!-- Nastaven√≠ tlaƒç√≠tko -->
    <button class="settings-toggle" @click.stop="showSettings = !showSettings; showVideoModal = !showVideoModal">‚öôÔ∏è</button>

    <!-- Video Modal -->
    <div class="settings-backdrop" v-if="showVideoModal" @click="showVideoModal = false"></div>
    <div class="video-modal" v-if="showVideoModal" @click.stop>
        <div class="card">
            <h2>üé¨ Vybrat video</h2>
            <div class="youtube-input">
                <input
                        type="text"
                        v-model="youtubeUrl"
                        placeholder="YouTube URL..."
                        @keyup.enter="loadVideoAndClose"
                >
                <button class="btn btn-primary" @click="loadVideoAndClose">Naƒç√≠st</button>
            </div>
            <div v-if="errorMessage" class="error-message">{{ errorMessage }}</div>

            <!-- Historie vide√≠ -->
            <div class="video-history" v-if="videoHistory.length > 0">
                <h3>üìú Historie</h3>
                <div class="history-list">
                    <div class="history-item" v-for="(item, index) in videoHistory" :key="item.id">
                        <div class="history-info" @click="loadFromHistoryAndClose(item)">
                            <span class="history-title">{{ item.title || item.id }}</span>
                            <span class="history-meta">
                                    <span v-if="item.duration" class="history-duration">{{ formatDuration(item.duration) }}</span>
                                    <span class="history-count">‚ñ∂ {{ item.playCount }}√ó</span>
                                </span>
                        </div>
                        <button class="history-delete" @click="deleteFromHistory(index)">‚úï</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Backdrop pro zav≈ôen√≠ -->
    <div class="settings-backdrop" v-if="showSettings" @click="showSettings = false"></div>

    <!-- Nastaven√≠ panel -->
    <div class="settings-panel" v-if="showSettings" @click.stop>
        <div class="card">
            <h2>‚öôÔ∏è Nastaven√≠</h2>
            <div class="settings-grid">
                <div class="setting-item">
                    <label>D√©lka tratƒõ (ƒças)</label>
                    <select v-model="selectedDuration" @change="onDurationChange">
                        <option value="15">15 minut</option>
                        <option value="30">30 minut</option>
                        <option value="45">45 minut</option>
                        <option value="60">1 hodina</option>
                        <option value="90">1,5 hodiny</option>
                        <option value="120">2 hodiny</option>
                        <option value="custom">Vlastn√≠</option>
                    </select>
                </div>
                <div class="setting-item" v-if="selectedDuration === 'custom'">
                    <label>Vlastn√≠ d√©lka (minuty): {{ trackDuration }}</label>
                    <input type="number" v-model.number="trackDuration" min="1" max="240" class="custom-input">
                </div>
                <div class="setting-item">
                    <label>Variabilita: {{ roughness }}</label>
                    <div class="value-adjuster">
                        <button class="btn btn-sm" @click="roughness = Math.max(1, roughness - 1)">‚àí</button>
                        <input type="range" v-model.number="roughness" min="1" max="10" step="1">
                        <button class="btn btn-sm" @click="roughness = Math.min(10, roughness + 1)">+</button>
                    </div>
                </div>
                <div class="setting-item">
                    <label>
                        <input type="checkbox" v-model="useRpmLoad"> Promƒõnliv√° z√°tƒõ≈æ (RPM)
                    </label>
                </div>
                <div class="setting-item">
                    <label>Min. z√°tƒõ≈æ: {{ minLoad }}</label>
                    <div class="value-adjuster">
                        <button class="btn btn-sm" @click="minLoad = Math.max(1, minLoad - 1)">‚àí</button>
                        <input type="range" v-model.number="minLoad" min="1" max="20" step="1">
                        <button class="btn btn-sm" @click="minLoad = Math.min(20, minLoad + 1)">+</button>
                    </div>
                </div>
                <div class="setting-item">
                    <label>Max. z√°tƒõ≈æ: {{ maxLoad }}</label>
                    <div class="value-adjuster">
                        <button class="btn btn-sm" @click="maxLoad = Math.max(1, maxLoad - 1)">‚àí</button>
                        <input type="range" v-model.number="maxLoad" min="1" max="20" step="1">
                        <button class="btn btn-sm" @click="maxLoad = Math.min(20, maxLoad + 1)">+</button>
                    </div>
                </div>
            </div>
            <div class="action-buttons" style="display: flex; gap: 10px;">
                <button class="btn btn-primary" @click="generateTrack">üîÑ Nov√° tra≈•</button>
                <button class="btn btn-secondary" @click="resetValues">‚Ü© Reset</button>
            </div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
<script>
    // === KONFIGURACE ===
    // Nastav IP adresu backendu (bez lom√≠tka na konci)
    // P≈ô√≠klad: 'http://192.168.1.100:3000' nebo '' pro relativn√≠ cesty
    const API_BASE_URL = '';
    // ===================

    const { createApp, ref, computed, watch, onMounted, onBeforeUnmount, nextTick } = Vue;

    createApp({
        setup() {
            // YouTube stav
            const youtubeUrl = ref('');
            const videoId = ref('');
            const playerReady = ref(false);
            const isPlaying = ref(false);
            const errorMessage = ref('');
            let player = null;

            // Video historie
            const videoHistory = ref([]);

            function loadVideoHistory() {
                const stored = localStorage.getItem('videoHistory');
                if (stored) {
                    videoHistory.value = JSON.parse(stored);
                }
            }

            function saveVideoHistory() {
                localStorage.setItem('videoHistory', JSON.stringify(videoHistory.value));
            }

            function addToHistory(id, title = null, duration = null) {
                const existing = videoHistory.value.find(v => v.id === id);
                if (existing) {
                    existing.playCount++;
                    if (title) existing.title = title;
                    if (duration) existing.duration = duration;
                } else {
                    videoHistory.value.unshift({
                        id: id,
                        title: title || id,
                        duration: duration,
                        playCount: 1,
                        addedAt: Date.now()
                    });
                    if (videoHistory.value.length > 20) {
                        videoHistory.value.pop();
                    }
                }
                saveVideoHistory();
                localStorage.setItem('lastVideoId', id);
            }

            function updateVideoMetadata() {
                if (!player) return;
                try {
                    const videoData = player.getVideoData();
                    const duration = player.getDuration();
                    if (videoData && videoData.title) {
                        addToHistory(videoId.value, videoData.title, duration);
                    }
                } catch (e) {
                    console.log('Could not get video metadata');
                }
            }

            function formatDuration(seconds) {
                if (!seconds) return '';
                const hrs = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                if (hrs > 0) {
                    return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            function loadFromHistory(item) {
                item.playCount++;
                saveVideoHistory();
                videoId.value = item.id;
                autoPlayOnReady = true;
                initPlayer();
            }

            function loadVideoAndClose() {
                loadVideo();
                if (!errorMessage.value) {
                    showVideoModal.value = false;
                }
            }

            function loadFromHistoryAndClose(item) {
                loadFromHistory(item);
                showVideoModal.value = false;
            }

            function deleteFromHistory(index) {
                videoHistory.value.splice(index, 1);
                saveVideoHistory();
            }

            // Statistiky
            const rpm = ref(75);
            const incline = ref(0);
            const load = ref(1);
            const loadOffset = ref(0);
            const rpmAnimating = ref(false);
            const inclineAnimating = ref(false);
            const loadAnimating = ref(false);

            async function sendBrakeToKettler(brakeValue) {
                try {
                    console.log(`[JS] Odes√≠l√°m z√°tƒõ≈æ na Kettler: ${brakeValue}`);
                    const res = await fetch(`${API_BASE_URL}/api/brake`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ brake: brakeValue })
                    });
                    const data = await res.json();
                    console.log(`[JS] Odpovƒõƒè serveru:`, data);
                } catch (e) {
                    console.error('Chyba p≈ôi odes√≠l√°n√≠ z√°tƒõ≈æe:', e);
                }
            }

            async function fetchRpmFromKettler() {
                try {
                    const res = await fetch(`${API_BASE_URL}/api/rpm`);
                    const data = await res.json();
                    if (data.rpm !== null && data.rpm !== undefined) {
                        if (data.rpm !== rpm.value) {
                            console.log(`[JS] RPM zmƒõnƒõno: ${rpm.value} -> ${data.rpm}`);
                        }
                        rpm.value = data.rpm;
                    }
                } catch (e) {
                    console.error('Chyba p≈ôi ƒçten√≠ RPM:', e);
                }
            }

            function increaseLoad() {
                if (load.value >= 20) return;
                loadOffset.value = loadOffset.value + 1;
                const newLoad = Math.min(20, load.value + 1);
                load.value = newLoad;
                sendBrakeToKettler(newLoad);
            }

            function decreaseLoad() {
                if (load.value <= 1) return;
                loadOffset.value = loadOffset.value - 1;
                const newLoad = Math.max(1, load.value - 1);
                load.value = newLoad;
                sendBrakeToKettler(newLoad);
            }

            // Nastaven√≠
            const minIncline = ref(-5);
            const maxIncline = ref(15);
            const showSettings = ref(false);
            const showVideoModal = ref(false);
            const showTrack = ref(true);
            const useRpmLoad = ref(false);
            const minLoad = ref(5);
            const maxLoad = ref(18);

            // Tra≈•
            const selectedDuration = ref('60');
            const trackDuration = ref(60); // minuty
            const trackLength = computed(() => trackDuration.value * 60); // 1 bod = 1 sekunda
            const roughness = ref(5);
            const trackPoints = ref([]);
            const cursorIndex = ref(0);

            // Zmƒõna d√©lky tratƒõ
            function onDurationChange() {
                if (selectedDuration.value !== 'custom') {
                    trackDuration.value = parseInt(selectedDuration.value);
                }
            }

            // Form√°tov√°n√≠ ƒçasu
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            // Canvas reference
            const trackCanvas = ref(null);

            // Zoom a posun grafu
            const trackZoom = ref(1); // 1 = cel√° tra≈•, 2 = polovina, atd.
            const trackOffset = ref(0); // posun v sekund√°ch

            function zoomIn() {
                trackZoom.value = Math.min(10, trackZoom.value * 1.5);
                adjustOffset();
            }

            function zoomOut() {
                trackZoom.value = Math.max(1, trackZoom.value / 1.5);
                adjustOffset();
            }

            function adjustOffset() {
                const maxOffset = Math.max(0, trackPoints.value.length - trackPoints.value.length / trackZoom.value);
                trackOffset.value = Math.min(trackOffset.value, maxOffset);
            }

            function scrollTrack(delta) {
                const step = Math.floor(trackPoints.value.length / trackZoom.value / 10);
                trackOffset.value = Math.max(0, Math.min(
                    trackPoints.value.length - trackPoints.value.length / trackZoom.value,
                    trackOffset.value + delta * step
                ));
                drawTrack();
            }

            function seekToPosition(event) {
                const canvas = trackCanvas.value;
                if (!canvas || trackPoints.value.length === 0) return;

                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const clickRatio = x / rect.width;

                // V√Ωpoƒçet indexu na z√°kladƒõ zoomu a offsetu
                const visiblePoints = Math.floor(trackPoints.value.length / trackZoom.value);
                const startIndex = Math.floor(trackOffset.value);
                const clickedIndex = Math.floor(startIndex + clickRatio * visiblePoints);

                // Nastaven√≠ nov√© pozice
                cursorIndex.value = Math.max(0, Math.min(trackPoints.value.length - 1, clickedIndex));
                drawTrack();
            }

            // Intervaly
            let tickInterval = null;

            // Parsov√°n√≠ YouTube URL
            function parseYouTubeUrl(url) {
                if (!url) return null;

                const patterns = [
                    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/,
                    /^([a-zA-Z0-9_-]{11})$/
                ];

                for (const pattern of patterns) {
                    const match = url.match(pattern);
                    if (match && match[1]) {
                        return match[1];
                    }
                }
                return null;
            }

            // Naƒçten√≠ videa
            function loadVideo() {
                errorMessage.value = '';
                const id = parseYouTubeUrl(youtubeUrl.value);

                if (!id) {
                    errorMessage.value = 'Neplatn√° YouTube URL. Podporovan√© form√°ty: youtube.com/watch?v=, youtu.be/, shorts/';
                    return;
                }

                videoId.value = id;
                addToHistory(id);
                autoPlayOnReady = true;
                initPlayer();
            }

            // Inicializace YouTube playeru
            function initPlayer() {
                if (!videoId.value) return;

                if (player) {
                    if (autoPlayOnReady) {
                        player.loadVideoById({
                            videoId: videoId.value,
                            suggestedQuality: 'hd720'
                        });
                    } else {
                        player.cueVideoById({
                            videoId: videoId.value,
                            suggestedQuality: 'hd720'
                        });
                    }
                    return;
                }

                player = new YT.Player('player', {
                    videoId: videoId.value,
                    playerVars: {
                        autoplay: 0,
                        controls: 0,
                        disablekb: 1,
                        fs: 0,
                        iv_load_policy: 3,
                        loop: 1,
                        modestbranding: 1,
                        mute: 1,
                        playlist: videoId.value,
                        playsinline: 1,
                        rel: 0,
                        showinfo: 0
                    },
                    events: {
                        onReady: onPlayerReady,
                        onStateChange: onPlayerStateChange
                    }
                });
            }

            let autoPlayOnReady = false;

            function onPlayerReady(event) {
                playerReady.value = true;
                event.target.setPlaybackQuality('hd720');
                if (autoPlayOnReady) {
                    event.target.playVideo();
                }
            }

            function onPlayerStateChange(event) {
                const wasPlaying = isPlaying.value;
                isPlaying.value = event.data === YT.PlayerState.PLAYING;

                // Synchronizace j√≠zdy s videem
                if (event.data === YT.PlayerState.PLAYING) {
                    // Video zaƒçalo hr√°t - spustit j√≠zdu
                    if (!tickInterval) {
                        tickInterval = setInterval(tick, 1000);
                    }
                    // Aktualizovat metadata videa (n√°zev, d√©lka)
                    updateVideoMetadata();
                } else if (event.data === YT.PlayerState.PAUSED) {
                    // Video pozastaveno - zastavit j√≠zdu
                    if (tickInterval) {
                        clearInterval(tickInterval);
                        tickInterval = null;
                    }
                } else if (event.data === YT.PlayerState.ENDED) {
                    // Video skonƒçilo d≈ô√≠v ne≈æ j√≠zda - pustit od zaƒç√°tku
                    if (cursorIndex.value < trackPoints.value.length - 1) {
                        player.seekTo(0);
                        player.playVideo();
                    } else {
                        // J√≠zda i video skonƒçily
                        if (tickInterval) {
                            clearInterval(tickInterval);
                            tickInterval = null;
                        }
                    }
                }
            }

            function playVideo() {
                // Zav≈ô√≠t modal pokud je otev≈ôen√Ω
                showVideoModal.value = false;

                if (player && playerReady.value) {
                    player.playVideo();
                } else {
                    // ≈Ω√°dn√© video naƒçten√© - zobrazit modal
                    showVideoModal.value = true;
                }
            }

            function pauseVideo() {
                if (player && playerReady.value) {
                    player.pauseVideo();
                }
            }

            function seekForward() {
                if (player && playerReady.value) {
                    const currentTime = player.getCurrentTime();
                    player.seekTo(currentTime + 30, true);
                }
            }

            function seekBackward() {
                if (player && playerReady.value) {
                    const currentTime = player.getCurrentTime();
                    player.seekTo(Math.max(0, currentTime - 30), true);
                }
            }

            // Generov√°n√≠ tratƒõ
            function generateTrack() {
                const points = [];
                let currentHeight = 0;

                // Generujeme segmenty s r≈Øznou d√©lkou podle variability
                let segmentLength = Math.floor(30 + Math.random() * 90); // 30s-2min na segment
                let targetHeight = 0;
                let segmentProgress = segmentLength;
                let startHeight = currentHeight;

                for (let i = 0; i < trackLength.value; i++) {
                    if (segmentProgress >= segmentLength) {
                        // Nov√Ω segment
                        segmentProgress = 0;
                        segmentLength = Math.floor(30 + Math.random() * 90); // Nov√° d√©lka segmentu
                        startHeight = currentHeight;

                        // Nov√° c√≠lov√° v√Ω≈°ka - s pravdƒõpodobnost√≠ rovn√©ho √∫seku
                        if (Math.random() < 0.3) {
                            // 30% ≈°ance na rovn√Ω √∫sek (kolem nuly)
                            targetHeight = (Math.random() - 0.5) * 2;
                        } else {
                            // Kopec nebo sjezd
                            const intensity = roughness.value / 5; // 0.2 a≈æ 2
                            const change = (Math.random() - 0.4) * 20 * intensity;
                            targetHeight = currentHeight + change;
                            targetHeight = Math.max(-8, Math.min(15, targetHeight));
                        }
                    }

                    // Plynul√° interpolace mezi startHeight a targetHeight
                    const t = segmentProgress / segmentLength;
                    // Pou≈æit√≠ hlad≈°√≠ quintic interpolace m√≠sto cubic
                    const smoothT = t * t * t * (t * (t * 6 - 15) + 10);
                    currentHeight = startHeight + (targetHeight - startHeight) * smoothT;

                    points.push(currentHeight);

                    segmentProgress++;
                }

                // Gaussovsk√© vyhlazen√≠ tratƒõ (v√≠ce pr≈Øchod≈Ø, ≈°ir≈°√≠ okno)
                for (let pass = 0; pass < 15; pass++) {
                    const temp = [...points];
                    for (let i = 2; i < points.length - 2; i++) {
                        // 5-bodov√Ω gaussovsk√Ω filtr pro hlad≈°√≠ p≈ôechody
                        temp[i] = (points[i - 2] + points[i - 1] * 4 + points[i] * 6 + points[i + 1] * 4 + points[i + 2]) / 16;
                    }
                    for (let i = 2; i < points.length - 2; i++) {
                        points[i] = temp[i];
                    }
                }

                trackPoints.value = points;
                cursorIndex.value = 0;
            }

            // Vykreslen√≠ tratƒõ
            function drawTrack() {
                const canvas = trackCanvas.value;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();

                canvas.width = rect.width * 2;
                canvas.height = rect.height * 2;
                ctx.scale(2, 2);

                const width = rect.width;
                const height = rect.height;

                ctx.clearRect(0, 0, width, height);

                if (trackPoints.value.length === 0) return;

                // Zoom a offset v√Ωpoƒçty
                const visiblePoints = Math.floor(trackPoints.value.length / trackZoom.value);
                const startIndex = Math.floor(trackOffset.value);
                const endIndex = Math.min(startIndex + visiblePoints, trackPoints.value.length);

                // Automaticky centrovat na kurzor p≈ôi zoomu
                if (trackZoom.value > 1) {
                    const idealStart = cursorIndex.value - visiblePoints / 2;
                    const newOffset = Math.max(0, Math.min(trackPoints.value.length - visiblePoints, idealStart));
                    if (Math.abs(trackOffset.value - newOffset) > visiblePoints * 0.4) {
                        trackOffset.value = newOffset;
                    }
                }

                const pointWidth = width / (visiblePoints - 1);

                // Naj√≠t min/max pro normalizaci
                const visibleData = trackPoints.value.slice(startIndex, endIndex);
                const minValue = Math.min(...visibleData);
                const maxValue = Math.max(...visibleData);
                const range = Math.max(maxValue - minValue, 1);

                // Funkce pro p≈ôevod hodnoty na Y pozici
                const valueToY = (value) => {
                    const normalized = (value - minValue) / range;
                    return height - (normalized * height * 0.8 + height * 0.1);
                };

                // Baseline (st≈ôed nebo nula)
                const zeroY = minValue <= 0 && maxValue >= 0 ? valueToY(0) : height / 2;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, zeroY);
                ctx.lineTo(width, zeroY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Gradient pro v√Ωpl≈à
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, 'rgba(0, 212, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 212, 255, 0.05)');

                // V√Ωpl≈à pod k≈ôivkou
                ctx.beginPath();
                ctx.moveTo(0, height);

                for (let i = startIndex; i < endIndex; i++) {
                    const x = (i - startIndex) * pointWidth;
                    const y = valueToY(trackPoints.value[i]);
                    ctx.lineTo(x, y);
                }

                ctx.lineTo(width, height);
                ctx.closePath();
                ctx.fillStyle = gradient;
                ctx.fill();

                // K≈ôivka profilu
                ctx.strokeStyle = '#00d4ff';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();

                for (let i = startIndex; i < endIndex; i++) {
                    const x = (i - startIndex) * pointWidth;
                    const y = valueToY(trackPoints.value[i]);

                    if (i === startIndex) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Aktu√°ln√≠ pozice (teƒçka) - pouze pokud je viditeln√°
                if (cursorIndex.value >= startIndex && cursorIndex.value < endIndex) {
                    const cursorX = (cursorIndex.value - startIndex) * pointWidth;
                    const cursorY = valueToY(trackPoints.value[cursorIndex.value]);

                    // Svisl√° ƒç√°ra
                    ctx.strokeStyle = 'rgba(255, 159, 67, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cursorX, 0);
                    ctx.lineTo(cursorX, height);
                    ctx.stroke();

                    // Teƒçka
                    ctx.beginPath();
                    ctx.arc(cursorX, cursorY, 8, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff9f43';
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Vnit≈ôn√≠ teƒçka
                    ctx.beginPath();
                    ctx.arc(cursorX, cursorY, 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                }
            }

            // Tick funkce (1√ó za sekundu)
            async function tick() {
                if (trackPoints.value.length === 0) return;

                // Naƒçten√≠ RPM z Kettleru
                await fetchRpmFromKettler();

                // Z√≠sk√°n√≠ aktu√°ln√≠ho bodu z grafu - gradient p≈ôes 10 sekund pro stabilnƒõj≈°√≠ hodnotu
                const lookAhead = 10;
                const currentPoint = trackPoints.value[cursorIndex.value];
                const futureIndex = Math.min(cursorIndex.value + lookAhead, trackPoints.value.length - 1);
                const futurePoint = trackPoints.value[futureIndex];

                // Update Incline (stoup√°n√≠ = rozd√≠l v√Ω≈°ek p≈ôepoƒçten√Ω na %)
                // Hodnoty v trackPoints jsou p≈ô√≠mo procenta stoup√°n√≠, tak≈æe bereme pr≈Ømƒõrn√Ω gradient
                const slope = (futurePoint - currentPoint) / lookAhead * 40;
                incline.value = Math.round(Math.max(minIncline.value, Math.min(maxIncline.value, slope)));

                // Update Load
                let baseLoad;
                if (useRpmLoad.value) {
                    // Promƒõnliv√° z√°tƒõ≈æ s RPM - realistick√Ω v√Ωpoƒçet odporu
                    const rollingResistance = 4;
                    const normalizedRpm = rpm.value / 75;
                    const airResistance = Math.round(3 * normalizedRpm * normalizedRpm);
                    const gravityLoad = incline.value > 0
                        ? incline.value * 2
                        : incline.value * 0.8;
                    baseLoad = Math.round(rollingResistance + airResistance + gravityLoad);
                } else {
                    // Jednoduch√° z√°tƒõ≈æ = pouze sklon (mapovan√Ω na rozsah minLoad-maxLoad)
                    const slopeRange = maxIncline.value - minIncline.value;
                    const normalizedSlope = (incline.value - minIncline.value) / (slopeRange || 1);
                    baseLoad = Math.round(minLoad.value + normalizedSlope * (maxLoad.value - minLoad.value));
                }
                const newLoad = Math.max(1, Math.min(20, baseLoad + loadOffset.value));
                if (newLoad !== load.value) {
                    load.value = newLoad;
                    sendBrakeToKettler(newLoad);
                }

                // Posun kurzoru
                cursorIndex.value = (cursorIndex.value + 1) % trackPoints.value.length;

                // P≈ôekreslit canvas
                drawTrack();
            }

            // Reset hodnot
            function resetValues() {
                rpm.value = 75;
                incline.value = 0;
                load.value = 15;
                cursorIndex.value = 0;
                drawTrack();
            }

            // Watch pro zmƒõny nastaven√≠
            watch([trackDuration, roughness], () => {
                generateTrack();
            });

            watch(trackPoints, () => {
                nextTick(() => drawTrack());
            }, { deep: true });

            // Lifecycle
            onMounted(() => {
                // Naƒçten√≠ video historie
                loadVideoHistory();

                // Naƒçten√≠ YouTube IFrame API
                const tag = document.createElement('script');
                tag.src = 'https://www.youtube.com/iframe_api';
                const firstScript = document.getElementsByTagName('script')[0];
                firstScript.parentNode.insertBefore(tag, firstScript);

                window.onYouTubeIframeAPIReady = () => {
                    console.log('YouTube API Ready');
                    // Zobrazit modal pro v√Ωbƒõr videa p≈ôi prvn√≠m naƒçten√≠
                    showVideoModal.value = true;
                };

                // Generov√°n√≠ poƒç√°teƒçn√≠ tratƒõ
                generateTrack();

                // Interval se spust√≠ a≈æ p≈ôi p≈ôehr√°n√≠ videa

                // Resize handler
                window.addEventListener('resize', drawTrack);

                // Poƒç√°teƒçn√≠ vykreslen√≠
                nextTick(() => {
                    drawTrack();
                });
            });

            onBeforeUnmount(() => {
                if (tickInterval) {
                    clearInterval(tickInterval);
                }
                if (player) {
                    player.destroy();
                }
                window.removeEventListener('resize', drawTrack);
            });

            return {
                // YouTube
                youtubeUrl,
                videoId,
                playerReady,
                isPlaying,
                errorMessage,
                loadVideo,
                playVideo,
                pauseVideo,
                seekForward,
                seekBackward,
                videoHistory,
                loadFromHistory,
                deleteFromHistory,
                formatDuration,

                // Stats
                rpm,
                incline,
                load,
                loadOffset,
                increaseLoad,
                decreaseLoad,
                rpmAnimating,
                inclineAnimating,
                loadAnimating,

                // Settings
                minIncline,
                maxIncline,
                showSettings,
                showVideoModal,
                loadVideoAndClose,
                loadFromHistoryAndClose,
                selectedDuration,
                trackDuration,
                onDurationChange,
                roughness,
                useRpmLoad,
                minLoad,
                maxLoad,

                // Track
                showTrack,
                trackPoints,
                cursorIndex,
                trackCanvas,
                trackZoom,
                zoomIn,
                zoomOut,
                scrollTrack,
                seekToPosition,
                generateTrack,
                resetValues,
                formatTime
            };
        }
    }).mount('#app');
</script>
</body>
</html>
