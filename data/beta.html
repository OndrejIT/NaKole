<!DOCTYPE html>
<html lang="cs">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NaKole</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            overflow-x: hidden;
            touch-action: pan-x pan-y;
        }

        /* YouTube video pozad√≠ */
        #youtube-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            pointer-events: none;
        }

        #youtube-background iframe {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100vw;
            height: 56.25vw;
            min-height: 100vh;
            min-width: 177.77vh;
            transform: translate(-50%, -50%);
        }

        /* Tmav√Ω overlay */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.15);
            z-index: -1;
        }

        /* Hlavn√≠ kontejner */
        .container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            pointer-events: none;
        }

        .container>* {
            pointer-events: auto;
        }

        /* Horn√≠ panel */
        .top-panel {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 20px;
            gap: 20px;
            flex-wrap: wrap;
        }

        /* Spodn√≠ graf */
        .bottom-panel {
            margin-top: auto;
            padding: 0;
        }

        .track-toggle {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 24px;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            color: #fff;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            z-index: 50;
            transition: all 0.3s ease;
        }

        .track-toggle:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        /* Karty */
        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card h2 {
            font-size: 0.9rem;
            margin-bottom: 12px;
            color: #00d4ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card.stats-card {
            padding: 12px;
        }

        .card.stats-card h2 {
            display: none;
        }

        .card.youtube-card {
            max-width: 400px;
        }

        .card.track-card {
            border-radius: 0;
            padding: 0;
            background: transparent;
            border: none;
            box-shadow: none;
            backdrop-filter: none;
        }

        /* YouTube input sekce */
        .youtube-input {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .youtube-input input {
            flex: 1;
            min-width: 200px;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            font-size: 1rem;
        }

        .youtube-input input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00e5ff, #00b8d4);
            color: #fff;
            box-shadow: 0 2px 10px rgba(0, 229, 255, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 229, 255, 0.5);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #69f0ae, #00e676);
            color: #1a1a2e;
            box-shadow: 0 2px 10px rgba(105, 240, 174, 0.3);
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(105, 240, 174, 0.5);
        }

        .btn-fullscreen {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .btn-fullscreen:hover {
            transform: translateY(-2px);
            background: rgba(255, 255, 255, 0.3);
        }

        .error-message {
            color: #ff6b6b;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        /* Stats grid */
        .stats-grid {
            display: flex;
            gap: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            min-width: 90px;
        }

        .stat-label {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            transition: all 0.3s ease;
        }

        .stat-value.rpm {
            color: #00e5ff;
            text-shadow: 0 0 10px rgba(0, 229, 255, 0.5);
        }

        .stat-value.incline {
            color: #ffc107;
            text-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
        }

        .stat-value.load {
            color: #ff5722;
            text-shadow: 0 0 10px rgba(255, 87, 34, 0.5);
        }

        .stat-value.time {
            color: #e040fb;
            text-shadow: 0 0 10px rgba(224, 64, 251, 0.5);
            font-size: 2rem;
        }

        .stat-value.time.finished {
            color: #4caf50;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.7);
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }
        }

        .stat-value.animate {
            transform: scale(1.1);
        }

        /* Load controls */
        .load-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 6px;
        }

        .load-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .load-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .load-offset {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
            min-width: 30px;
            text-align: center;
        }

        /* Nastaven√≠ */
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 16px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-item label {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .setting-item input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
        }

        .setting-item select {
            padding: 10px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            font-size: 1rem;
        }

        .setting-item select option {
            background: #1a1a2e;
        }

        .custom-input {
            padding: 10px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            font-size: 1rem;
            width: 100%;
        }

        .value-adjuster {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .value-adjuster input[type="range"] {
            flex: 1;
        }

        .btn-sm {
            padding: 4px 10px;
            font-size: 1rem;
            min-width: 32px;
        }

        /* Canvas kontejner */
        .canvas-container {
            width: 100%;
            height: 25vh;
            min-height: 150px;
            position: relative;
            background: transparent;
        }

        .canvas-container canvas {
            width: 100%;
            height: 100%;
        }

        .track-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.5);
            padding: 6px 12px;
            border-radius: 20px;
        }

        .track-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .track-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .zoom-level {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.7);
            min-width: 40px;
            text-align: center;
        }

        /* Tlaƒç√≠tka akce */
        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 16px;
        }

        /* Video controls */
        .video-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }

        /* Settings toggle */
        .settings-toggle {
            position: fixed;
            bottom: 30vh;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            color: #fff;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .settings-toggle:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.1);
        }

        /* Settings backdrop */
        .settings-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 98;
        }

        /* Video modal */
        .video-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 400px;
            width: 90%;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            z-index: 99;
        }

        /* Settings panel */
        .settings-panel {
            position: fixed;
            bottom: 30vh;
            right: 80px;
            max-width: 350px;
            max-height: calc(70vh - 20px);
            overflow-y: auto;
            z-index: 99;
        }

        .youtube-card {
            z-index: 100;
            position: relative;
        }

        .settings-panel .card {
            max-height: none;
        }

        .settings-panel .settings-grid {
            grid-template-columns: 1fr;
        }

        /* Video history */
        .video-history {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .video-history h3 {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
        }

        .history-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 150px;
            overflow-y: auto;
        }

        .history-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .history-info {
            flex: 1;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .history-info:hover {
            color: #00d4ff;
        }

        .history-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 180px;
        }

        .history-meta {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .history-duration {
            color: #00d4ff;
            font-size: 0.75rem;
        }

        .history-count {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.75rem;
        }

        .history-delete {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.4);
            cursor: pointer;
            padding: 4px;
            font-size: 0.9rem;
        }

        .history-delete:hover {
            color: #ff6b6b;
        }

        /* Responzivita */
        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }

            .card {
                padding: 16px;
            }

            .stat-value {
                font-size: 2rem;
            }
        }

        /* Animace fade */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .card {
            animation: fadeIn 0.5s ease forwards;
        }

        .card:nth-child(2) {
            animation-delay: 0.1s;
        }

        .card:nth-child(3) {
            animation-delay: 0.2s;
        }

        .card:nth-child(4) {
            animation-delay: 0.3s;
        }
    </style>
</head>

<body>
<div id="app">
    <!-- YouTube pozad√≠ -->
    <div id="youtube-background">
        <div :id="'player'"></div>
    </div>

    <!-- Overlay -->
    <div class="overlay"></div>

    <!-- Hlavn√≠ obsah -->
    <div class="container">
        <!-- Horn√≠ panel -->
        <div class="top-panel">
            <!-- Statistiky - lev√Ω horn√≠ roh -->
            <div class="card stats-card">
                <h2>üìä Aktu√°ln√≠ hodnoty</h2>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">ƒåas</div>
                        <div class="stat-value time" :class="{ finished: isFinished }">{{ formatTime(cursorIndex) }}
                        </div>
                        <div class="stat-label">/ {{ formatTime(trackPoints.length) }}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Kadence</div>
                        <div class="stat-value rpm">{{ rpm }}</div>
                        <div class="stat-label">RPM</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Stoup√°n√≠</div>
                        <div class="stat-value incline">{{ incline > 0 ? '+' : '' }}{{ incline }}%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Z√°tƒõ≈æ</div>
                        <div class="stat-value load">{{ load }}</div>
                        <div class="load-controls">
                            <button class="load-btn" @click="decreaseLoad">‚àí</button>
                            <span class="load-offset">{{ loadOffset >= 0 ? '+' : '' }}{{ loadOffset }}</span>
                            <button class="load-btn" @click="increaseLoad">+</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Video controls - prav√Ω horn√≠ roh -->
            <div class="card youtube-card">
                <div class="video-controls">
                    <button class="btn btn-secondary" @click="seekBackward"
                            v-if="videoId && playerReady">‚óÄ‚óÄ</button>
                    <button class="btn btn-success" @click="playVideo" v-if="!isPlaying && !isFinished">‚ñ∂</button>
                    <button class="btn btn-secondary" @click="pauseVideo" v-if="isPlaying">‚èê‚èê</button>
                    <button class="btn btn-secondary" @click="seekForward" v-if="videoId && playerReady">‚ñ∂‚ñ∂</button>
                    <button class="btn btn-fullscreen" @click="toggleFullscreen">‚§¢</button>
                </div>
            </div>
        </div>

        <!-- Spodn√≠ panel - Graf tratƒõ -->
        <div class="bottom-panel" v-if="showTrack">
            <div class="card track-card">
                <div class="canvas-container">
                    <canvas ref="trackCanvas" @click="seekToPosition($event)" style="cursor: pointer;"></canvas>
                    <div class="track-controls">
                        <button class="track-btn" @click="scrollTrack(-1)">‚óÄ</button>
                        <button class="track-btn" @click="zoomOut">‚àí</button>
                        <span class="zoom-level">{{ Math.round(trackZoom * 100) }}%</span>
                        <button class="track-btn" @click="zoomIn">+</button>
                        <button class="track-btn" @click="scrollTrack(1)">‚ñ∂</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Toggle graf -->
        <button class="track-toggle" @click="showTrack = !showTrack">
            {{ showTrack ? '‚ñº' : '‚ñ≤' }}
        </button>
    </div>

    <!-- Nastaven√≠ tlaƒç√≠tko -->
    <button class="settings-toggle"
            @click.stop="showSettings = !showSettings; showVideoModal = !showVideoModal">‚öôÔ∏è</button>

    <!-- Video Modal -->
    <div class="settings-backdrop" v-if="showVideoModal" @click="showVideoModal = false; showSettings = false">
    </div>
    <div class="video-modal" v-if="showVideoModal" @click.stop>
        <div class="card">
            <h2>üé¨ Vybrat video</h2>
            <div class="youtube-input">
                <input type="text" v-model="youtubeUrl" placeholder="YouTube URL..."
                       @keyup.enter="loadVideoAndClose">
                <button class="btn btn-primary" @click="loadVideoAndClose">Naƒç√≠st</button>
            </div>
            <div v-if="errorMessage" class="error-message">{{ errorMessage }}</div>

            <!-- Historie vide√≠ -->
            <div class="video-history" v-if="videoHistory.length > 0">
                <h3>üìú Historie</h3>
                <div class="history-list">
                    <div class="history-item" v-for="(item, index) in videoHistory" :key="item.id">
                        <div class="history-info" @click="loadFromHistoryAndClose(item)">
                            <span class="history-title">{{ item.title || item.id }}</span>
                            <span class="history-meta">
                                    <span v-if="item.duration" class="history-duration">{{ formatDuration(item.duration)
                                        }}</span>
                                    <span class="history-count">‚ñ∂ {{ item.playCount }}√ó</span>
                                </span>
                        </div>
                        <button class="history-delete" @click="deleteFromHistory(index)">‚úï</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Backdrop pro zav≈ôen√≠ -->
    <div class="settings-backdrop" v-if="showSettings && !showVideoModal"
         @click="showSettings = false; showVideoModal = false"></div>

    <!-- Nastaven√≠ panel -->
    <div class="settings-panel" v-if="showSettings" @click.stop>
        <div class="card">
            <h2>‚öôÔ∏è Nastaven√≠</h2>
            <div class="settings-grid">
                <div class="setting-item">
                    <label>D√©lka tratƒõ (ƒças)</label>
                    <select v-model="selectedDuration" @change="onDurationChange">
                        <option value="15">15 minut</option>
                        <option value="30">30 minut</option>
                        <option value="45">45 minut</option>
                        <option value="60">1 hodina</option>
                        <option value="90">1,5 hodiny</option>
                        <option value="120">2 hodiny</option>
                        <option value="custom">Vlastn√≠</option>
                    </select>
                </div>
                <div class="setting-item" v-if="selectedDuration === 'custom'">
                    <label>Vlastn√≠ d√©lka (minuty): {{ trackDuration }}</label>
                    <input type="number" v-model.number="trackDuration" min="1" max="240" class="custom-input">
                </div>
                <div class="setting-item">
                    <label>Variabilita: {{ roughness }}</label>
                    <div class="value-adjuster">
                        <button class="btn btn-sm" @click="roughness = Math.max(1, roughness - 1)">‚ûñ</button>
                        <input type="range" v-model.number="roughness" min="1" max="10" step="1">
                        <button class="btn btn-sm" @click="roughness = Math.min(10, roughness + 1)">‚ûï</button>
                    </div>
                </div>
                <div class="setting-item">
                    <label>
                        <input type="checkbox" v-model="useRpmLoad"> Promƒõnliv√° z√°tƒõ≈æ (RPM)
                    </label>
                </div>
                <div class="setting-item">
                    <label>Min. z√°tƒõ≈æ: {{ minLoad }}</label>
                    <div class="value-adjuster">
                        <button class="btn btn-sm" @click="minLoad = Math.max(1, minLoad - 1)">‚ûñ</button>
                        <input type="range" v-model.number="minLoad" min="1" max="20" step="1">
                        <button class="btn btn-sm" @click="minLoad = Math.min(20, minLoad + 1)">‚ûï</button>
                    </div>
                </div>
                <div class="setting-item">
                    <label>Max. z√°tƒõ≈æ: {{ maxLoad }}</label>
                    <div class="value-adjuster">
                        <button class="btn btn-sm" @click="maxLoad = Math.max(1, maxLoad - 1)">‚ûñ</button>
                        <input type="range" v-model.number="maxLoad" min="1" max="20" step="1">
                        <button class="btn btn-sm" @click="maxLoad = Math.min(20, maxLoad + 1)">‚ûï</button>
                    </div>
                </div>
            </div>
            <div class="action-buttons" style="display: flex; gap: 10px;">
                <button class="btn btn-primary" @click="generateTrack">üîÑ Nov√° tra≈•</button>
                <button class="btn btn-secondary" @click="resetValues">‚Ü© Reset</button>
            </div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
<script>
    // === KONFIGURACE ===
    // Nastav IP adresu backendu (bez lom√≠tka na konci)
    // P≈ô√≠klad: 'http://192.168.1.100:3000' nebo '' pro relativn√≠ cesty
    const API_BASE_URL = '';
    // ===================

    const { createApp, ref, computed, watch, onMounted, onBeforeUnmount, nextTick } = Vue;

    createApp({
        setup() {
            // YouTube stav
            const youtubeUrl = ref('');
            const videoId = ref('');
            const playerReady = ref(false);
            const isPlaying = ref(false);
            const errorMessage = ref('');
            let player = null;

            // Video historie
            const videoHistory = ref([]);

            function loadVideoHistory() {
                const stored = localStorage.getItem('videoHistory');
                if (stored) {
                    videoHistory.value = JSON.parse(stored);
                }
            }

            function saveVideoHistory() {
                localStorage.setItem('videoHistory', JSON.stringify(videoHistory.value));
            }

            function addToHistory(id, title = null, duration = null) {
                const existing = videoHistory.value.find(v => v.id === id);
                if (existing) {
                    existing.playCount++;
                    if (title) existing.title = title;
                    if (duration) existing.duration = duration;
                } else {
                    videoHistory.value.unshift({
                        id: id,
                        title: title || id,
                        duration: duration,
                        playCount: 1,
                        addedAt: Date.now()
                    });
                    if (videoHistory.value.length > 20) {
                        videoHistory.value.pop();
                    }
                }
                saveVideoHistory();
                localStorage.setItem('lastVideoId', id);
            }

            function updateVideoMetadata() {
                if (!player) return;
                try {
                    const videoData = player.getVideoData();
                    const duration = player.getDuration();
                    if (videoData && videoData.title) {
                        addToHistory(videoId.value, videoData.title, duration);
                    }
                } catch (e) {
                    console.log('Could not get video metadata');
                }
            }

            function formatDuration(seconds) {
                if (!seconds) return '';
                const hrs = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                if (hrs > 0) {
                    return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            function loadFromHistory(item) {
                item.playCount++;
                saveVideoHistory();
                videoId.value = item.id;
                autoPlayOnReady = true;
                initPlayer();
            }

            function loadVideoAndClose() {
                loadVideo();
                if (!errorMessage.value) {
                    showVideoModal.value = false;
                }
            }

            function loadFromHistoryAndClose(item) {
                loadFromHistory(item);
                showVideoModal.value = false;
            }

            function deleteFromHistory(index) {
                videoHistory.value.splice(index, 1);
                saveVideoHistory();
            }

            // Statistiky
            const rpm = ref(75);
            const incline = ref(0);
            const load = ref(1);
            const loadOffset = ref(0);
            const currentBaseLoad = ref(0);
            const rpmAnimating = ref(false);
            const inclineAnimating = ref(false);
            const loadAnimating = ref(false);

            async function sendBrakeToKettler(brakeValue) {
                try {
                    console.log(`[JS] Odes√≠l√°m z√°tƒõ≈æ na Kettler: ${brakeValue}`);
                    const res = await fetch(`${API_BASE_URL}/api/brake`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ brake: brakeValue })
                    });
                    const data = await res.json();
                    console.log(`[JS] Odpovƒõƒè serveru:`, data);
                } catch (e) {
                    console.error('Chyba p≈ôi odes√≠l√°n√≠ z√°tƒõ≈æe:', e);
                }
            }

            async function fetchRpmFromKettler() {
                try {
                    const res = await fetch(`${API_BASE_URL}/api/rpm`);
                    const data = await res.json();
                    if (data.rpm !== null && data.rpm !== undefined) {
                        if (data.rpm !== rpm.value) {
                            console.log(`[JS] RPM zmƒõnƒõno: ${rpm.value} -> ${data.rpm}`);
                        }
                        rpm.value = data.rpm;
                    }
                } catch (e) {
                    console.error('Chyba p≈ôi ƒçten√≠ RPM:', e);
                }
            }

            function increaseLoad() {
                const targetLoad = Math.min(20, load.value + 1);
                if (targetLoad !== load.value) {
                    // P≈ôepoƒç√≠tat offset tak, aby base + offset = target
                    // offset = target - base
                    loadOffset.value = targetLoad - currentBaseLoad.value;
                    load.value = targetLoad;
                    sendBrakeToKettler(targetLoad);
                }
            }

            function decreaseLoad() {
                const targetLoad = Math.max(1, load.value - 1);
                if (targetLoad !== load.value) {
                    // P≈ôepoƒç√≠tat offset tak, aby base + offset = target
                    loadOffset.value = targetLoad - currentBaseLoad.value;
                    load.value = targetLoad;
                    sendBrakeToKettler(targetLoad);
                }
            }

            // Nastaven√≠
            const minIncline = ref(-5);
            const maxIncline = ref(15);
            const showSettings = ref(false);
            const showVideoModal = ref(false);
            const showTrack = ref(true);
            const useRpmLoad = ref(false);
            const minLoad = ref(5);
            const maxLoad = ref(18);
            const isFinished = ref(false);

            // Wake Lock pro prevenci usp√°n√≠ iPadu
            let wakeLock = null;

            async function requestWakeLock() {
                try {
                    if ('wakeLock' in navigator) {
                        wakeLock = await navigator.wakeLock.request('screen');
                        console.log('Wake Lock aktivov√°n');
                        wakeLock.addEventListener('release', () => {
                            console.log('Wake Lock uvolnƒõn');
                        });
                    }
                } catch (err) {
                    console.log('Wake Lock nelze aktivovat:', err);
                }
            }

            async function releaseWakeLock() {
                if (wakeLock) {
                    await wakeLock.release();
                    wakeLock = null;
                }
            }

            // Detekce zastaven√≠ ≈°lap√°n√≠
            let zeroRpmCount = 0;
            const ZERO_RPM_PAUSE_THRESHOLD = 5; // sekund bez ≈°lap√°n√≠ = pauza

            // Fullscreen
            function toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.log('Fullscreen error:', err);
                    });
                } else {
                    document.exitFullscreen();
                }
            }

            // Tra≈•
            const selectedDuration = ref('60');
            const trackDuration = ref(60); // minuty
            const trackLength = computed(() => trackDuration.value * 60); // 1 bod = 1 sekunda
            const roughness = ref(5);
            const trackPoints = ref([]);
            const trackSegments = ref([]); // Segmenty tratƒõ pro zobrazen√≠ zmƒõn
            const cursorIndex = ref(0);

            // Zmƒõna d√©lky tratƒõ
            function onDurationChange() {
                if (selectedDuration.value !== 'custom') {
                    trackDuration.value = parseInt(selectedDuration.value);
                }
            }

            // Form√°tov√°n√≠ ƒçasu
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            // Canvas reference
            const trackCanvas = ref(null);

            // Zoom a posun grafu
            const trackZoom = ref(1); // 1 = cel√° tra≈•, 2 = polovina, atd.
            const trackOffset = ref(0); // posun v sekund√°ch

            function zoomIn() {
                trackZoom.value = Math.min(10, trackZoom.value * 1.5);
                adjustOffset();
            }

            function zoomOut() {
                trackZoom.value = Math.max(1, trackZoom.value / 1.5);
                adjustOffset();
            }

            function adjustOffset() {
                const maxOffset = Math.max(0, trackPoints.value.length - trackPoints.value.length / trackZoom.value);
                trackOffset.value = Math.min(trackOffset.value, maxOffset);
            }

            function scrollTrack(delta) {
                const step = Math.floor(trackPoints.value.length / trackZoom.value / 10);
                trackOffset.value = Math.max(0, Math.min(
                    trackPoints.value.length - trackPoints.value.length / trackZoom.value,
                    trackOffset.value + delta * step
                ));
                drawTrack();
            }

            function seekToPosition(event) {
                const canvas = trackCanvas.value;
                if (!canvas || trackPoints.value.length === 0) return;

                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const clickRatio = x / rect.width;

                // V√Ωpoƒçet indexu na z√°kladƒõ zoomu a offsetu
                const visiblePoints = Math.floor(trackPoints.value.length / trackZoom.value);
                const startIndex = Math.floor(trackOffset.value);
                const clickedIndex = Math.floor(startIndex + clickRatio * visiblePoints);

                // Nastaven√≠ nov√© pozice
                cursorIndex.value = Math.max(0, Math.min(trackPoints.value.length - 1, clickedIndex));
                drawTrack();
            }

            // Intervaly
            let tickInterval = null;

            // Parsov√°n√≠ YouTube URL
            function parseYouTubeUrl(url) {
                if (!url) return null;

                const patterns = [
                    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/,
                    /^([a-zA-Z0-9_-]{11})$/
                ];

                for (const pattern of patterns) {
                    const match = url.match(pattern);
                    if (match && match[1]) {
                        return match[1];
                    }
                }
                return null;
            }

            // Naƒçten√≠ videa
            function loadVideo() {
                errorMessage.value = '';
                const id = parseYouTubeUrl(youtubeUrl.value);

                if (!id) {
                    errorMessage.value = 'Neplatn√° YouTube URL. Podporovan√© form√°ty: youtube.com/watch?v=, youtu.be/, shorts/';
                    return;
                }

                videoId.value = id;
                addToHistory(id);
                autoPlayOnReady = true;
                initPlayer();
            }

            // Inicializace YouTube playeru
            function initPlayer() {
                if (!videoId.value) return;

                if (player) {
                    if (autoPlayOnReady) {
                        player.loadVideoById({
                            videoId: videoId.value,
                            suggestedQuality: 'hd720'
                        });
                    } else {
                        player.cueVideoById({
                            videoId: videoId.value,
                            suggestedQuality: 'hd720'
                        });
                    }
                    return;
                }

                player = new YT.Player('player', {
                    videoId: videoId.value,
                    playerVars: {
                        autoplay: 0,
                        controls: 0,
                        disablekb: 1,
                        fs: 0,
                        iv_load_policy: 3,
                        loop: 1,
                        modestbranding: 1,
                        mute: 1,
                        playlist: videoId.value,
                        playsinline: 1,
                        rel: 0,
                        showinfo: 0
                    },
                    events: {
                        onReady: onPlayerReady,
                        onStateChange: onPlayerStateChange
                    }
                });
            }

            let autoPlayOnReady = false;

            function onPlayerReady(event) {
                playerReady.value = true;
                event.target.setPlaybackQuality('hd720');
                if (autoPlayOnReady) {
                    event.target.playVideo();
                }
            }

            function onPlayerStateChange(event) {
                const wasPlaying = isPlaying.value;
                isPlaying.value = event.data === YT.PlayerState.PLAYING;

                // Synchronizace j√≠zdy s videem
                if (event.data === YT.PlayerState.PLAYING) {
                    // Video zaƒçalo hr√°t - spustit j√≠zdu
                    if (!tickInterval) {
                        tickInterval = setInterval(tick, 1000);
                    }
                    // Aktivovat Wake Lock
                    requestWakeLock();
                    // Aktualizovat metadata videa (n√°zev, d√©lka)
                    updateVideoMetadata();
                } else if (event.data === YT.PlayerState.PAUSED) {
                    // Video pozastaveno - zastavit j√≠zdu
                    if (tickInterval) {
                        clearInterval(tickInterval);
                        tickInterval = null;
                    }
                    releaseWakeLock();
                } else if (event.data === YT.PlayerState.ENDED) {
                    // Video skonƒçilo d≈ô√≠v ne≈æ j√≠zda - pustit od zaƒç√°tku
                    if (cursorIndex.value < trackPoints.value.length - 1) {
                        player.seekTo(0);
                        player.playVideo();
                    } else {
                        // J√≠zda i video skonƒçily
                        if (tickInterval) {
                            clearInterval(tickInterval);
                            tickInterval = null;
                        }
                    }
                }
            }

            function playVideo() {
                // Zav≈ô√≠t modal pokud je otev≈ôen√Ω
                showVideoModal.value = false;

                if (player && playerReady.value) {
                    player.playVideo();
                } else {
                    // ≈Ω√°dn√© video naƒçten√© - zobrazit modal
                    showVideoModal.value = true;
                }
            }

            function pauseVideo() {
                if (player && playerReady.value) {
                    player.pauseVideo();
                }
            }

            function seekForward() {
                if (player && playerReady.value) {
                    const currentTime = player.getCurrentTime();
                    player.seekTo(currentTime + 60, true);
                }
            }

            function seekBackward() {
                if (player && playerReady.value) {
                    const currentTime = player.getCurrentTime();
                    player.seekTo(Math.max(0, currentTime - 60), true);
                }
            }

            // Generov√°n√≠ tratƒõ
            function generateTrack() {
                const length = trackLength.value; // celkov√° d√©lka v sekund√°ch
                const variability = roughness.value; // 1-10

                // Parametry sklonu - pracujeme p≈ô√≠mo s procenty stoup√°n√≠
                const minSlopePercent = minIncline.value; // nap≈ô. -5%
                const maxSlopePercent = maxIncline.value; // nap≈ô. 15%

                // St≈ôed rozsahu (typicky m√≠rn√© stoup√°n√≠ kolem 3-5%)
                const midSlope = (minSlopePercent + maxSlopePercent) / 2;
                // ≈†√≠≈ôka "komfortn√≠ z√≥ny" - 40% celkov√©ho rozsahu kolem st≈ôedu
                const comfortRange = (maxSlopePercent - minSlopePercent) * 0.4;

                // 1. Generov√°n√≠ c√≠lov√Ωch sklon≈Ø pro segmenty
                const avgSegmentDuration = 300 - (variability * 25);

                let currentStep = 0;
                const slopeTargets = []; // { time, slope, type }
                slopeTargets.push({ time: 0, slope: 0, type: 'start' });

                let hasExtreme = false; // jeden extr√©mn√≠ bod (max nebo min)
                let segmentCount = 0;

                while (currentStep < length) {
                    currentStep += avgSegmentDuration * (0.7 + Math.random() * 0.6);
                    if (currentStep > length) currentStep = length;
                    segmentCount++;

                    let nextSlope;
                    let segmentType;
                    const roll = Math.random();

                    // Distribuce ter√©nu:
                    // 40% - rovina nebo m√≠rn√Ω ter√©n (kolem 0%)
                    // 35% - m√≠rn√© stoup√°n√≠/kles√°n√≠ (30-60% rozsahu)
                    // 15% - st≈ôedn√≠ stoup√°n√≠/kles√°n√≠ (60-80% rozsahu)
                    // 8% - prudk√© stoup√°n√≠/kles√°n√≠ (80-95% rozsahu)
                    // 2% - extr√©mn√≠ (95-100% rozsahu) - max 1√ó za tra≈•

                    if (roll < 0.40) {
                        // Rovina nebo velmi m√≠rn√Ω ter√©n
                        nextSlope = (Math.random() - 0.5) * 3; // -1.5% a≈æ +1.5%
                        segmentType = 'flat';
                    } else if (roll < 0.75) {
                        // M√≠rn√© stoup√°n√≠ nebo kles√°n√≠
                        const intensity = 0.3 + Math.random() * 0.3; // 30-60% rozsahu
                        if (Math.random() < 0.6) {
                            // ƒåastƒõji stoup√°n√≠
                            nextSlope = maxSlopePercent * intensity;
                        } else {
                            // M√©nƒõ ƒçasto kles√°n√≠
                            nextSlope = minSlopePercent * intensity;
                        }
                        segmentType = 'gentle';
                    } else if (roll < 0.90) {
                        // St≈ôedn√≠ ter√©n
                        const intensity = 0.6 + Math.random() * 0.2; // 60-80% rozsahu
                        if (Math.random() < 0.5) {
                            nextSlope = maxSlopePercent * intensity;
                        } else {
                            nextSlope = minSlopePercent * intensity;
                        }
                        segmentType = 'moderate';
                    } else if (roll < 0.98 || hasExtreme) {
                        // Prudk√Ω ter√©n (ale ne maximum)
                        const intensity = 0.8 + Math.random() * 0.15; // 80-95% rozsahu
                        if (Math.random() < 0.5) {
                            nextSlope = maxSlopePercent * intensity;
                        } else {
                            nextSlope = minSlopePercent * intensity;
                        }
                        segmentType = 'steep';
                    } else {
                        // Extr√©mn√≠ bod - jen 1√ó za celou tra≈•
                        const intensity = 0.95 + Math.random() * 0.05; // 95-100%
                        if (Math.random() < 0.5) {
                            nextSlope = maxSlopePercent * intensity;
                            segmentType = 'peak';
                        } else {
                            nextSlope = minSlopePercent * intensity;
                            segmentType = 'valley';
                        }
                        hasExtreme = true;
                    }

                    // Variabilita ovliv≈àuje ≈°√≠≈ôi rozptylu
                    if (variability < 5) {
                        // N√≠zk√° variabilita - zmen≈°√≠me extr√©my
                        nextSlope *= (0.5 + variability * 0.1);
                    }

                    // Clamp na povolen√Ω rozsah
                    nextSlope = Math.max(minSlopePercent, Math.min(maxSlopePercent, nextSlope));

                    slopeTargets.push({
                        time: Math.floor(currentStep),
                        slope: nextSlope / 4, // P≈ôevod na intern√≠ jednotky pro altitude
                        type: segmentType,
                        percent: Math.round(nextSlope) // Pro debug
                    });
                }

                // Debug v√Ωpis segment≈Ø
                console.log('=== VYGENEROVAN√Å TRA≈§ ===');
                console.log(`D√©lka: ${length}s, Segment≈Ø: ${slopeTargets.length}`);
                console.log(`Rozsah sklonu: ${minSlopePercent}% a≈æ ${maxSlopePercent}%`);
                slopeTargets.forEach((s, i) => {
                    console.log(`  [${i}] t=${s.time}s, sklon=${s.percent || 0}%, typ=${s.type}`);
                });

                // 2. Interpolace sklonu a Integrace na V√Ω≈°ku
                const points = [];
                let currentAltitude = 0;
                let targetIndex = 0;
                let currentSlopeVal = 0;

                for (let t = 0; t < length; t++) {
                    while (targetIndex < slopeTargets.length - 1 && t >= slopeTargets[targetIndex].time) {
                        targetIndex++;
                    }

                    const prevTarget = slopeTargets[targetIndex - 1] || { time: 0, slope: 0 };
                    const nextTarget = slopeTargets[targetIndex];

                    const segmentDuration = nextTarget.time - prevTarget.time;
                    const segmentProgress = segmentDuration === 0 ? 0 : (t - prevTarget.time) / segmentDuration;
                    const p = Math.max(0, Math.min(1, segmentProgress));

                    // Cosine interpolation pro hladk√© p≈ôechody
                    const mu2 = (1 - Math.cos(p * Math.PI)) / 2;
                    currentSlopeVal = prevTarget.slope * (1 - mu2) + nextTarget.slope * mu2;

                    currentAltitude += currentSlopeVal;
                    points.push(currentAltitude);
                }

                trackPoints.value = points;
                trackSegments.value = slopeTargets; // Ulo≈æit segmenty pro debug zobrazen√≠
                cursorIndex.value = 0;
                isFinished.value = false;

                zeroRpmCount = 0;
                releaseWakeLock();
            }

            // Vykreslen√≠ tratƒõ
            function drawTrack() {
                const canvas = trackCanvas.value;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();

                canvas.width = rect.width * 2;
                canvas.height = rect.height * 2;
                ctx.scale(2, 2);

                const width = rect.width;
                const height = rect.height;

                ctx.clearRect(0, 0, width, height);

                if (trackPoints.value.length === 0) return;

                // Zoom a offset v√Ωpoƒçty
                const visiblePoints = Math.floor(trackPoints.value.length / trackZoom.value);
                const startIndex = Math.floor(trackOffset.value);
                const endIndex = Math.min(startIndex + visiblePoints, trackPoints.value.length);

                // Automaticky centrovat na kurzor p≈ôi zoomu
                if (trackZoom.value > 1) {
                    const idealStart = cursorIndex.value - visiblePoints / 2;
                    const newOffset = Math.max(0, Math.min(trackPoints.value.length - visiblePoints, idealStart));
                    if (Math.abs(trackOffset.value - newOffset) > visiblePoints * 0.4) {
                        trackOffset.value = newOffset;
                    }
                }

                const pointWidth = width / (visiblePoints - 1);

                // Naj√≠t min/max pro normalizaci
                const visibleData = trackPoints.value.slice(startIndex, endIndex);
                const minValue = Math.min(...visibleData);
                const maxValue = Math.max(...visibleData);
                const range = Math.max(maxValue - minValue, 1);

                // Funkce pro p≈ôevod hodnoty na Y pozici
                const valueToY = (value) => {
                    const normalized = (value - minValue) / range;
                    return height - (normalized * height * 0.8 + height * 0.1);
                };

                // Funkce pro z√≠sk√°n√≠ barvy podle sklonu
                // Modr√° = sjezd, Zelen√° = rovina, Oran≈æov√° = m√≠rn√©/st≈ôedn√≠ stoup√°n√≠, ƒåerven√° = prudk√© stoup√°n√≠
                const getSlopeColor = (slopePercent) => {
                    if (slopePercent < -1) {
                        // Sjezd - modr√° (ƒç√≠m prud≈°√≠, t√≠m tmav≈°√≠)
                        const intensity = Math.min(1, Math.abs(slopePercent) / 8);
                        return `rgb(${Math.round(50 - intensity * 30)}, ${Math.round(150 + intensity * 50)}, ${Math.round(220 + intensity * 35)})`;
                    } else if (slopePercent <= 1) {
                        // Rovina - zelen√°
                        return 'rgb(50, 205, 50)';
                    } else if (slopePercent <= 10) {
                        // M√≠rn√© a≈æ st≈ôedn√≠ stoup√°n√≠ - p≈ôechod ze zelen√© p≈ôes oran≈æovou
                        const t = (slopePercent - 1) / 9; // 0 a≈æ 1
                        // Zelen√° (50,205,50) -> Oran≈æov√° (255,165,0) -> Tmav≈°√≠ oran≈æov√° (255,100,0)
                        const r = Math.round(50 + t * 205);
                        const g = Math.round(205 - t * 105);
                        const b = Math.round(50 - t * 50);
                        return `rgb(${r}, ${g}, ${b})`;
                    } else {
                        // Prudk√© stoup√°n√≠ - ƒçerven√° (ƒç√≠m prud≈°√≠, t√≠m tmav≈°√≠)
                        const intensity = Math.min(1, (slopePercent - 10) / 8);
                        return `rgb(${Math.round(220 - intensity * 50)}, ${Math.round(50 - intensity * 30)}, ${Math.round(30)})`;
                    }
                };

                // Baseline (st≈ôed nebo nula)
                const zeroY = minValue <= 0 && maxValue >= 0 ? valueToY(0) : height / 2;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, zeroY);
                ctx.lineTo(width, zeroY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Funkce pro nalezen√≠ AKTU√ÅLN√çHO segmentu (ve kter√©m jsme)
                // Segment plat√≠ od sv√©ho ƒçasu a≈æ do ƒçasu dal≈°√≠ho segmentu
                const getSegmentForTime = (time) => {
                    let currentSeg = trackSegments.value[0];
                    for (const seg of trackSegments.value) {
                        if (seg.time <= time) {
                            currentSeg = seg;
                        } else {
                            break;
                        }
                    }
                    return currentSeg;
                };

                // Funkce pro nalezen√≠ N√ÅSLEDUJ√çC√çHO segmentu (kam se zmƒõn√≠)
                const getNextSegmentForTime = (time) => {
                    for (const seg of trackSegments.value) {
                        if (seg.time > time) {
                            return seg;
                        }
                    }
                    return null; // ≈Ω√°dn√Ω dal≈°√≠ segment
                };

                // Barevn√° v√Ωpl≈à pod k≈ôivkou podle segmentu
                for (let i = startIndex; i < endIndex - 1; i++) {
                    const x1 = (i - startIndex) * pointWidth;
                    const x2 = (i + 1 - startIndex) * pointWidth;
                    const y1 = valueToY(trackPoints.value[i]);
                    const y2 = valueToY(trackPoints.value[i + 1]);

                    // Barva podle c√≠lov√©ho sklonu segmentu
                    const segment = getSegmentForTime(i);
                    const segmentSlope = segment.percent || 0;
                    const color = getSlopeColor(segmentSlope);

                    // V√Ωpl≈à sloupce
                    ctx.beginPath();
                    ctx.moveTo(x1, height);
                    ctx.lineTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x2, height);
                    ctx.closePath();
                    ctx.fillStyle = color.replace('rgb', 'rgba').replace(')', ', 0.4)');
                    ctx.fill();
                }

                // K≈ôivka profilu - barevn√° podle segmentu
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                for (let i = startIndex; i < endIndex - 1; i++) {
                    const x1 = (i - startIndex) * pointWidth;
                    const x2 = (i + 1 - startIndex) * pointWidth;
                    const y1 = valueToY(trackPoints.value[i]);
                    const y2 = valueToY(trackPoints.value[i + 1]);

                    // Barva podle c√≠lov√©ho sklonu segmentu
                    const segment = getSegmentForTime(i);
                    const segmentSlope = segment.percent || 0;

                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.strokeStyle = getSlopeColor(segmentSlope);
                    ctx.stroke();
                }

                // Aktu√°ln√≠ pozice (teƒçka) - pouze pokud je viditeln√°
                if (cursorIndex.value >= startIndex && cursorIndex.value < endIndex) {
                    const cursorX = (cursorIndex.value - startIndex) * pointWidth;
                    const cursorY = valueToY(trackPoints.value[cursorIndex.value]);

                    // Svisl√° ƒç√°ra
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cursorX, 0);
                    ctx.lineTo(cursorX, height);
                    ctx.stroke();

                    // Teƒçka
                    ctx.beginPath();
                    ctx.arc(cursorX, cursorY, 8, 0, Math.PI * 2);
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Vnit≈ôn√≠ teƒçka - barva podle aktu√°ln√≠ho sklonu
                    const lookAhead = 10;
                    const currentPoint = trackPoints.value[cursorIndex.value];
                    const futureIdx = Math.min(cursorIndex.value + lookAhead, trackPoints.value.length - 1);
                    const futurePoint = trackPoints.value[futureIdx];
                    const debugSlope = Math.round((futurePoint - currentPoint) / lookAhead * 4);
                    const clampedSlope = Math.max(minIncline.value, Math.min(maxIncline.value, debugSlope));

                    // ƒåas
                    const debugTime = formatTime(cursorIndex.value);
                    const totalTime = formatTime(trackPoints.value.length);

                    // Rozsahy pro v√Ωpoƒçet z√°tƒõ≈æe
                    const inclineRange = maxIncline.value - minIncline.value;
                    const loadRange = maxLoad.value - minLoad.value;

                    // Naj√≠t AKTU√ÅLN√ç segment (ve kter√©m jsme) a N√ÅSLEDUJ√çC√ç segment (kam se zmƒõn√≠)
                    let currentSegment = getSegmentForTime(cursorIndex.value);
                    let nextSegment = getNextSegmentForTime(cursorIndex.value);
                    let timeToNext = nextSegment ? nextSegment.time - cursorIndex.value : 0;

                    // Aktu√°ln√≠ sklon (to co odpov√≠d√° barvƒõ tratƒõ)
                    const segmentSlope = currentSegment ? (currentSegment.percent || 0) : 0;
                    const segmentLabel = segmentSlope < -1 ? 'Sjezd' :
                        segmentSlope <= 1 ? 'Rovina' :
                            segmentSlope <= 10 ? 'Stoup√°n√≠' : 'Prudk√©';

                    // V√Ωpoƒçet odpov√≠daj√≠c√≠ z√°tƒõ≈æe ze segmentu
                    const normalizedSegment = inclineRange > 0 ? (segmentSlope - minIncline.value) / inclineRange : 0.5;
                    const segmentLoad = Math.round(minLoad.value + normalizedSegment * loadRange);

                    // Barva teƒçky podle AKTU√ÅLN√çHO segmentu
                    ctx.beginPath();
                    ctx.arc(cursorX, cursorY, 5, 0, Math.PI * 2);
                    ctx.fillStyle = getSlopeColor(segmentSlope);
                    ctx.fill();

                    // Debug box
                    const boxHeight = 100;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                    ctx.fillRect(10, 10, 320, boxHeight);
                    ctx.strokeStyle = getSlopeColor(segmentSlope);
                    ctx.lineWidth = 2;
                    ctx.strokeRect(10, 10, 320, boxHeight);

                    // Debug text
                    ctx.font = '12px monospace';

                    // ƒåas
                    ctx.fillStyle = '#fff';
                    ctx.fillText(`‚è±Ô∏è ƒåas: ${debugTime} / ${totalTime}`, 20, 26);

                    // Aktu√°ln√≠ segment (odpov√≠d√° barvƒõ tratƒõ)
                    ctx.fillStyle = getSlopeColor(segmentSlope);
                    ctx.fillText(`üìê Nyn√≠: ${segmentSlope}% (${segmentLabel}) ‚Üí z√°tƒõ≈æ ${segmentLoad}`, 20, 44);

                    // Od kdy je tento segment
                    if (currentSegment) {
                        const timeInSegment = cursorIndex.value - currentSegment.time;
                        ctx.fillStyle = 'rgba(255,255,255,0.7)';
                        ctx.fillText(`   od ${formatTime(currentSegment.time)}, trv√° ${formatTime(timeInSegment)}`, 20, 60);
                    }

                    // Za jak dlouho se zmƒõn√≠ z√°tƒõ≈æ
                    if (nextSegment) {
                        const nextLabel = nextSegment.percent < -1 ? 'Sjezd' :
                            nextSegment.percent <= 1 ? 'Rovina' :
                                nextSegment.percent <= 10 ? 'Stoup√°n√≠' : 'Prudk√©';
                        const normalizedNext = inclineRange > 0 ? (nextSegment.percent - minIncline.value) / inclineRange : 0.5;
                        const nextLoad = Math.round(minLoad.value + normalizedNext * loadRange);

                        ctx.fillStyle = getSlopeColor(nextSegment.percent);
                        ctx.fillText(`üîú Zmƒõna za ${formatTime(timeToNext)}: ${nextLabel} ${nextSegment.percent}% ‚Üí ${nextLoad}`, 20, 78);
                    } else {
                        ctx.fillStyle = 'rgba(255,255,255,0.5)';
                        ctx.fillText(`üèÅ Posledn√≠ segment`, 20, 78);
                    }

                    // Zb√Ωvaj√≠c√≠ ƒças do konce
                    const remainingTime = trackPoints.value.length - cursorIndex.value;
                    ctx.fillStyle = 'rgba(255,255,255,0.6)';
                    ctx.fillText(`‚è≥ Zb√Ωv√°: ${formatTime(remainingTime)}`, 20, 96);
                }
            }

            // Tick funkce (1√ó za sekundu)
            async function tick() {
                if (trackPoints.value.length === 0) return;

                // Naƒçten√≠ RPM z Kettleru
                await fetchRpmFromKettler();

                // Z√≠sk√°n√≠ aktu√°ln√≠ho bodu z grafu - gradient p≈ôes 10 sekund pro stabilnƒõj≈°√≠ hodnotu
                const lookAhead = 10;
                const currentPoint = trackPoints.value[cursorIndex.value];
                const futureIndex = Math.min(cursorIndex.value + lookAhead, trackPoints.value.length - 1);
                const futurePoint = trackPoints.value[futureIndex];

                // Update Incline (stoup√°n√≠ = rozd√≠l v√Ω≈°ek p≈ôepoƒçten√Ω na %)
                // V generateTrack ukl√°d√°me: slope / 4, tak≈æe pro zpƒõtn√Ω p≈ôevod n√°sob√≠me 4
                // (futurePoint - currentPoint) = slopeVal * lookAhead, kde slopeVal = realSlope / 4
                // realSlope = (futurePoint - currentPoint) / lookAhead * 4
                const slope = (futurePoint - currentPoint) / lookAhead * 4;
                incline.value = Math.round(Math.max(minIncline.value, Math.min(maxIncline.value, slope)));

                // Update Load - line√°rn√≠ mapov√°n√≠ z [minIncline, maxIncline] na [minLoad, maxLoad]
                let baseLoad;
                if (useRpmLoad.value) {
                    // Promƒõnliv√° z√°tƒõ≈æ s RPM - realistick√Ω v√Ωpoƒçet odporu
                    const rollingResistance = 4;
                    const normalizedRpm = rpm.value / 75;
                    const airResistance = Math.round(3 * normalizedRpm * normalizedRpm);
                    // Gravitaƒçn√≠ slo≈æka - mapovan√° z [minIncline, maxIncline] na odpov√≠daj√≠c√≠ rozsah
                    const inclineRange = maxIncline.value - minIncline.value;
                    const normalizedIncline = inclineRange > 0 ? (incline.value - minIncline.value) / inclineRange : 0.5;
                    const gravityLoad = (normalizedIncline - 0.5) * 10; // -5 a≈æ +5 podle sklonu
                    baseLoad = Math.round(rollingResistance + airResistance + gravityLoad);
                } else {
                    // Line√°rn√≠ mapov√°n√≠: minIncline ‚Üí minLoad, maxIncline ‚Üí maxLoad
                    const inclineRange = maxIncline.value - minIncline.value;
                    const loadRange = maxLoad.value - minLoad.value;
                    // Normalizace sklonu na [0, 1]
                    const normalizedIncline = inclineRange > 0 ? (incline.value - minIncline.value) / inclineRange : 0.5;
                    // Mapov√°n√≠ na z√°tƒõ≈æ
                    baseLoad = Math.round(minLoad.value + normalizedIncline * loadRange);
                }

                currentBaseLoad.value = baseLoad;

                const newLoad = Math.max(1, Math.min(20, baseLoad + loadOffset.value));
                if (newLoad !== load.value) {
                    load.value = newLoad;
                    sendBrakeToKettler(newLoad);
                }

                // Detekce zastaven√≠ ≈°lap√°n√≠ - pausnout video
                if (rpm.value === 0) {
                    zeroRpmCount++;
                    if (zeroRpmCount >= ZERO_RPM_PAUSE_THRESHOLD && isPlaying.value) {
                        console.log('Automatick√° pauza - ≈°lap√°n√≠ zastaveno');
                        pauseVideo();
                    }
                } else {
                    zeroRpmCount = 0;
                }

                // Posun kurzoru - BEZ loopov√°n√≠
                if (cursorIndex.value < trackPoints.value.length - 1) {
                    cursorIndex.value++;
                } else {
                    // Konec j√≠zdy!
                    isFinished.value = true;
                    pauseVideo();
                    releaseWakeLock();
                    console.log('J√≠zda dokonƒçena!');
                }

                // P≈ôekreslit canvas
                drawTrack();
            }

            // Reset hodnot
            function resetValues() {
                rpm.value = 75;
                incline.value = 0;
                load.value = 15;
                cursorIndex.value = 0;
                isFinished.value = false;
                zeroRpmCount = 0;
                drawTrack();
            }

            // Watch pro zmƒõny nastaven√≠
            watch([trackDuration, roughness], () => {
                generateTrack();
            });

            watch(trackPoints, () => {
                nextTick(() => drawTrack());
            }, { deep: true });

            // Lifecycle
            onMounted(() => {
                // Naƒçten√≠ video historie
                loadVideoHistory();

                // Naƒçten√≠ YouTube IFrame API
                const tag = document.createElement('script');
                tag.src = 'https://www.youtube.com/iframe_api';
                const firstScript = document.getElementsByTagName('script')[0];
                firstScript.parentNode.insertBefore(tag, firstScript);

                window.onYouTubeIframeAPIReady = () => {
                    console.log('YouTube API Ready');
                    // Zobrazit modal pro v√Ωbƒõr videa p≈ôi prvn√≠m naƒçten√≠
                    showVideoModal.value = true;
                };

                // Generov√°n√≠ poƒç√°teƒçn√≠ tratƒõ
                generateTrack();

                // Interval se spust√≠ a≈æ p≈ôi p≈ôehr√°n√≠ videa

                // Resize handler
                window.addEventListener('resize', drawTrack);

                // Poƒç√°teƒçn√≠ vykreslen√≠
                nextTick(() => {
                    drawTrack();
                });
            });

            onBeforeUnmount(() => {
                if (tickInterval) {
                    clearInterval(tickInterval);
                }
                if (player) {
                    player.destroy();
                }
                window.removeEventListener('resize', drawTrack);
            });

            return {
                // YouTube
                youtubeUrl,
                videoId,
                playerReady,
                isPlaying,
                errorMessage,
                loadVideo,
                playVideo,
                pauseVideo,
                seekForward,
                seekBackward,
                videoHistory,
                loadFromHistory,
                deleteFromHistory,
                formatDuration,

                // Stats
                rpm,
                incline,
                load,
                loadOffset,
                increaseLoad,
                decreaseLoad,
                rpmAnimating,
                inclineAnimating,
                loadAnimating,

                // Settings
                minIncline,
                maxIncline,
                showSettings,
                showVideoModal,
                loadVideoAndClose,
                loadFromHistoryAndClose,
                selectedDuration,
                trackDuration,
                onDurationChange,
                roughness,
                useRpmLoad,
                minLoad,
                maxLoad,

                // Track
                showTrack,
                trackPoints,
                cursorIndex,
                trackCanvas,
                trackZoom,
                zoomIn,
                zoomOut,
                scrollTrack,
                seekToPosition,
                generateTrack,
                resetValues,
                formatTime,
                isFinished,
                toggleFullscreen
            };
        }
    }).mount('#app');
</script>
</body>

</html>