<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtu√°ln√≠ Cyklo Trena≈æ√©r</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            background: #1a1a2e;
            color: #fff;
            overflow-x: hidden;
        }

        /* YouTube video pozad√≠ */
        #youtube-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            pointer-events: none;
        }

        #youtube-background iframe {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100vw;
            height: 56.25vw;
            min-height: 100vh;
            min-width: 177.77vh;
            transform: translate(-50%, -50%);
        }

        /* Tmav√Ω overlay */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.15);
            z-index: -1;
        }

        /* Hlavn√≠ kontejner */
        .container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            pointer-events: none;
        }

        .container > * {
            pointer-events: auto;
        }

        /* Horn√≠ panel */
        .top-panel {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 20px;
            gap: 20px;
            flex-wrap: wrap;
        }

        /* Spodn√≠ graf */
        .bottom-panel {
            margin-top: auto;
            padding: 0;
        }

        .track-toggle {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 24px;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            color: #fff;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            z-index: 50;
            transition: all 0.3s ease;
        }

        .track-toggle:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        /* Karty */
        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card h2 {
            font-size: 0.9rem;
            margin-bottom: 12px;
            color: #00d4ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card.stats-card {
            padding: 12px;
        }

        .card.stats-card h2 {
            display: none;
        }

        .card.youtube-card {
            max-width: 400px;
        }

        .card.track-card {
            border-radius: 0;
            padding: 0;
            background: transparent;
            border: none;
            box-shadow: none;
            backdrop-filter: none;
        }

        /* YouTube input sekce */
        .youtube-input {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .youtube-input input {
            flex: 1;
            min-width: 200px;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            font-size: 1rem;
        }

        .youtube-input input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #1a1a2e;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.4);
        }

        .error-message {
            color: #ff6b6b;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        /* Stats grid */
        .stats-grid {
            display: flex;
            gap: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            min-width: 90px;
        }

        .stat-label {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            transition: all 0.3s ease;
        }

        .stat-value.rpm {
            color: #00d4ff;
        }

        .stat-value.incline {
            color: #ff9f43;
        }

        .stat-value.load {
            color: #ee5a24;
        }

        .stat-value.time {
            color: #a29bfe;
            font-size: 2rem;
        }

        .stat-value.animate {
            transform: scale(1.1);
        }

        /* Load controls */
        .load-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 6px;
        }

        .load-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .load-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .load-offset {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
            min-width: 30px;
            text-align: center;
        }

        /* Nastaven√≠ */
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 16px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-item label {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .setting-item input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
        }

        .setting-item select {
            padding: 10px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            font-size: 1rem;
        }

        .setting-item select option {
            background: #1a1a2e;
        }

        .custom-input {
            padding: 10px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            font-size: 1rem;
            width: 100%;
        }

        /* Canvas kontejner */
        .canvas-container {
            width: 100%;
            height: 25vh;
            min-height: 150px;
            position: relative;
            background: transparent;
        }

        .canvas-container canvas {
            width: 100%;
            height: 100%;
        }

        .track-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.5);
            padding: 6px 12px;
            border-radius: 20px;
        }

        .track-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .track-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .zoom-level {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.7);
            min-width: 40px;
            text-align: center;
        }

        /* Tlaƒç√≠tka akce */
        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 16px;
        }

        /* Video controls */
        .video-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        /* Settings toggle */
        .settings-toggle {
            position: fixed;
            bottom: 30vh;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            color: #fff;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .settings-toggle:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.1);
        }

        /* Settings backdrop */
        .settings-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 98;
        }

        /* Settings panel */
        .settings-panel {
            position: fixed;
            bottom: calc(25vh + 20px);
            right: 20px;
            max-width: 350px;
            z-index: 99;
        }

        .settings-panel .card {
            max-height: 60vh;
            overflow-y: auto;
        }

        .settings-panel .settings-grid {
            grid-template-columns: 1fr;
        }

        /* Video history */
        .video-history {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .video-history h3 {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
        }

        .history-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 150px;
            overflow-y: auto;
        }

        .history-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .history-info {
            flex: 1;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .history-info:hover {
            color: #00d4ff;
        }

        .history-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 180px;
        }

        .history-count {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.75rem;
        }

        .history-delete {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.4);
            cursor: pointer;
            padding: 4px;
            font-size: 0.9rem;
        }

        .history-delete:hover {
            color: #ff6b6b;
        }

        /* Responzivita */
        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }

            .card {
                padding: 16px;
            }

            .stat-value {
                font-size: 2rem;
            }
        }

        /* Animace fade */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card {
            animation: fadeIn 0.5s ease forwards;
        }

        .card:nth-child(2) { animation-delay: 0.1s; }
        .card:nth-child(3) { animation-delay: 0.2s; }
        .card:nth-child(4) { animation-delay: 0.3s; }
    </style>
</head>
<body>
    <div id="app">
        <!-- YouTube pozad√≠ -->
        <div id="youtube-background">
            <div :id="'player'"></div>
        </div>
        
        <!-- Overlay -->
        <div class="overlay"></div>

        <!-- Hlavn√≠ obsah -->
        <div class="container">
            <!-- Horn√≠ panel -->
            <div class="top-panel">
                <!-- Statistiky - lev√Ω horn√≠ roh -->
                <div class="card stats-card">
                    <h2>üìä Aktu√°ln√≠ hodnoty</h2>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-label">ƒåas</div>
                            <div class="stat-value time">{{ formatTime(cursorIndex) }}</div>
                            <div class="stat-label">/ {{ formatTime(trackPoints.length) }}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Kadence</div>
                            <div class="stat-value rpm" :class="{ animate: rpmAnimating }">{{ rpm }}</div>
                            <div class="stat-label">RPM</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Stoup√°n√≠</div>
                            <div class="stat-value incline" :class="{ animate: inclineAnimating }">{{ incline > 0 ? '+' : '' }}{{ incline }}%</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Z√°tƒõ≈æ</div>
                            <div class="stat-value load" :class="{ animate: loadAnimating }">{{ load }}</div>
                            <div class="load-controls">
                                <button class="load-btn" @click="decreaseLoad">‚àí</button>
                                <span class="load-offset">{{ loadOffset >= 0 ? '+' : '' }}{{ loadOffset }}</span>
                                <button class="load-btn" @click="increaseLoad">+</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Video controls - prav√Ω horn√≠ roh -->
                <div class="card youtube-card" v-if="videoId && playerReady">
                    <div class="video-controls">
                        <button class="btn btn-secondary" @click="seekBackward">‚è™ -30s</button>
                        <button class="btn btn-success" @click="playVideo" v-if="!isPlaying">‚ñ∂ Play</button>
                        <button class="btn btn-secondary" @click="pauseVideo" v-if="isPlaying">‚è∏ Pause</button>
                        <button class="btn btn-secondary" @click="seekForward">+30s ‚è©</button>
                    </div>
                </div>
            </div>

            <!-- Spodn√≠ panel - Graf tratƒõ -->
            <div class="bottom-panel" v-if="showTrack">
                <div class="card track-card">
                    <div class="canvas-container">
                        <canvas ref="trackCanvas" @click="seekToPosition($event)" style="cursor: pointer;"></canvas>
                        <div class="track-controls">
                            <button class="track-btn" @click="scrollTrack(-1)">‚óÄ</button>
                            <button class="track-btn" @click="zoomOut">‚àí</button>
                            <span class="zoom-level">{{ Math.round(trackZoom * 100) }}%</span>
                            <button class="track-btn" @click="zoomIn">+</button>
                            <button class="track-btn" @click="scrollTrack(1)">‚ñ∂</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Toggle graf -->
            <button class="track-toggle" @click="showTrack = !showTrack">
                {{ showTrack ? '‚ñº' : '‚ñ≤' }}
            </button>
        </div>
        
        <!-- Nastaven√≠ tlaƒç√≠tko -->
        <button class="settings-toggle" @click.stop="showSettings = !showSettings">‚öôÔ∏è</button>
        
        <!-- Backdrop pro zav≈ôen√≠ -->
        <div class="settings-backdrop" v-if="showSettings" @click="showSettings = false"></div>
        
        <!-- Nastaven√≠ panel -->
        <div class="settings-panel" v-if="showSettings" @click.stop>
            <div class="card">
                <h2>üé¨ YouTube Video</h2>
                <div class="youtube-input">
                    <input 
                        type="text" 
                        v-model="youtubeUrl" 
                        placeholder="YouTube URL..."
                        @keyup.enter="loadVideo"
                    >
                    <button class="btn btn-primary" @click="loadVideo">Naƒç√≠st</button>
                </div>
                <div v-if="errorMessage" class="error-message">{{ errorMessage }}</div>
                
                <!-- Historie vide√≠ -->
                <div class="video-history" v-if="videoHistory.length > 0">
                    <h3>üìú Historie</h3>
                    <div class="history-list">
                        <div class="history-item" v-for="(item, index) in videoHistory" :key="item.id">
                            <div class="history-info" @click="loadFromHistory(item)">
                                <span class="history-title">{{ item.title || item.id }}</span>
                                <span class="history-count">‚ñ∂ {{ item.playCount }}√ó</span>
                            </div>
                            <button class="history-delete" @click="deleteFromHistory(index)">‚úï</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="card" style="margin-top: 10px;">
                <h2>‚öôÔ∏è Nastaven√≠</h2>
                <div class="settings-grid">
                    <div class="setting-item">
                        <label>Min. stoup√°n√≠: {{ minIncline }}%</label>
                        <input type="range" v-model.number="minIncline" min="-15" max="0" step="1">
                    </div>
                    <div class="setting-item">
                        <label>Max. stoup√°n√≠: {{ maxIncline }}%</label>
                        <input type="range" v-model.number="maxIncline" min="0" max="25" step="1">
                    </div>
                    <div class="setting-item">
                        <label>D√©lka tratƒõ (ƒças)</label>
                        <select v-model="selectedDuration" @change="onDurationChange">
                            <option value="5">5 minut</option>
                            <option value="15">15 minut</option>
                            <option value="30">30 minut</option>
                            <option value="45">45 minut</option>
                            <option value="60">1 hodina</option>
                            <option value="90">1,5 hodiny</option>
                            <option value="120">2 hodiny</option>
                            <option value="custom">Vlastn√≠</option>
                        </select>
                    </div>
                    <div class="setting-item" v-if="selectedDuration === 'custom'">
                        <label>Vlastn√≠ d√©lka (minuty): {{ trackDuration }}</label>
                        <input type="number" v-model.number="trackDuration" min="1" max="240" class="custom-input">
                    </div>
                    <div class="setting-item">
                        <label>Variabilita: {{ roughness }}</label>
                        <input type="range" v-model.number="roughness" min="1" max="10" step="1">
                    </div>
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary" @click="generateTrack">üîÑ Pregenerovat tra≈•</button>
                    <button class="btn btn-secondary" @click="resetValues">‚Ü© Reset</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script>
        const { createApp, ref, computed, watch, onMounted, onBeforeUnmount, nextTick } = Vue;

        createApp({
            setup() {
                // YouTube stav
                const youtubeUrl = ref('');
                const videoId = ref('');
                const playerReady = ref(false);
                const isPlaying = ref(false);
                const errorMessage = ref('');
                let player = null;

                // Video historie
                const videoHistory = ref([]);

                function loadVideoHistory() {
                    const stored = localStorage.getItem('videoHistory');
                    if (stored) {
                        videoHistory.value = JSON.parse(stored);
                    }
                }

                function saveVideoHistory() {
                    localStorage.setItem('videoHistory', JSON.stringify(videoHistory.value));
                }

                function addToHistory(id) {
                    const existing = videoHistory.value.find(v => v.id === id);
                    if (existing) {
                        existing.playCount++;
                    } else {
                        videoHistory.value.unshift({
                            id: id,
                            title: id,
                            playCount: 1,
                            addedAt: Date.now()
                        });
                        if (videoHistory.value.length > 20) {
                            videoHistory.value.pop();
                        }
                    }
                    saveVideoHistory();
                    localStorage.setItem('lastVideoId', id);
                }

                function loadFromHistory(item) {
                    item.playCount++;
                    saveVideoHistory();
                    videoId.value = item.id;
                    autoPlayOnReady = true;
                    initPlayer();
                }

                function deleteFromHistory(index) {
                    videoHistory.value.splice(index, 1);
                    saveVideoHistory();
                }

                // Statistiky
                const rpm = ref(75);
                const incline = ref(0);
                const load = ref(15);
                const loadOffset = ref(0);
                const rpmAnimating = ref(false);
                const inclineAnimating = ref(false);
                const loadAnimating = ref(false);

                function increaseLoad() {
                    loadOffset.value = Math.min(15, loadOffset.value + 5);
                }

                function decreaseLoad() {
                    loadOffset.value = Math.max(-15, loadOffset.value - 5);
                }

                // Nastaven√≠
                const minIncline = ref(-5);
                const maxIncline = ref(15);
                const showSettings = ref(false);
                const showTrack = ref(true);

                // Tra≈•
                const selectedDuration = ref('30');
                const trackDuration = ref(30); // minuty
                const trackLength = computed(() => trackDuration.value * 60); // 1 bod = 1 sekunda
                const roughness = ref(5);
                const trackPoints = ref([]);
                const cursorIndex = ref(0);

                // Zmƒõna d√©lky tratƒõ
                function onDurationChange() {
                    if (selectedDuration.value !== 'custom') {
                        trackDuration.value = parseInt(selectedDuration.value);
                    }
                }

                // Form√°tov√°n√≠ ƒçasu
                function formatTime(seconds) {
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                }

                // Canvas reference
                const trackCanvas = ref(null);

                // Zoom a posun grafu
                const trackZoom = ref(1); // 1 = cel√° tra≈•, 2 = polovina, atd.
                const trackOffset = ref(0); // posun v sekund√°ch

                function zoomIn() {
                    trackZoom.value = Math.min(10, trackZoom.value * 1.5);
                    adjustOffset();
                }

                function zoomOut() {
                    trackZoom.value = Math.max(1, trackZoom.value / 1.5);
                    adjustOffset();
                }

                function adjustOffset() {
                    const maxOffset = Math.max(0, trackPoints.value.length - trackPoints.value.length / trackZoom.value);
                    trackOffset.value = Math.min(trackOffset.value, maxOffset);
                }

                function scrollTrack(delta) {
                    const step = Math.floor(trackPoints.value.length / trackZoom.value / 10);
                    trackOffset.value = Math.max(0, Math.min(
                        trackPoints.value.length - trackPoints.value.length / trackZoom.value,
                        trackOffset.value + delta * step
                    ));
                    drawTrack();
                }

                function seekToPosition(event) {
                    const canvas = trackCanvas.value;
                    if (!canvas || trackPoints.value.length === 0) return;

                    const rect = canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const clickRatio = x / rect.width;

                    // V√Ωpoƒçet indexu na z√°kladƒõ zoomu a offsetu
                    const visiblePoints = Math.floor(trackPoints.value.length / trackZoom.value);
                    const startIndex = Math.floor(trackOffset.value);
                    const clickedIndex = Math.floor(startIndex + clickRatio * visiblePoints);

                    // Nastaven√≠ nov√© pozice
                    cursorIndex.value = Math.max(0, Math.min(trackPoints.value.length - 1, clickedIndex));
                    drawTrack();
                }

                // Intervaly
                let tickInterval = null;

                // Parsov√°n√≠ YouTube URL
                function parseYouTubeUrl(url) {
                    if (!url) return null;
                    
                    const patterns = [
                        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/,
                        /^([a-zA-Z0-9_-]{11})$/
                    ];

                    for (const pattern of patterns) {
                        const match = url.match(pattern);
                        if (match && match[1]) {
                            return match[1];
                        }
                    }
                    return null;
                }

                // Naƒçten√≠ videa
                function loadVideo() {
                    errorMessage.value = '';
                    const id = parseYouTubeUrl(youtubeUrl.value);
                    
                    if (!id) {
                        errorMessage.value = 'Neplatn√° YouTube URL. Podporovan√© form√°ty: youtube.com/watch?v=, youtu.be/, shorts/';
                        return;
                    }

                    videoId.value = id;
                    addToHistory(id);
                    autoPlayOnReady = true;
                    initPlayer();
                }

                // Inicializace YouTube playeru
                function initPlayer() {
                    if (!videoId.value) return;

                    if (player) {
                        if (autoPlayOnReady) {
                            player.loadVideoById({
                                videoId: videoId.value,
                                suggestedQuality: 'hd720'
                            });
                        } else {
                            player.cueVideoById({
                                videoId: videoId.value,
                                suggestedQuality: 'hd720'
                            });
                        }
                        return;
                    }

                    player = new YT.Player('player', {
                        videoId: videoId.value,
                        playerVars: {
                            autoplay: 0,
                            controls: 0,
                            disablekb: 1,
                            fs: 0,
                            iv_load_policy: 3,
                            loop: 1,
                            modestbranding: 1,
                            mute: 1,
                            playlist: videoId.value,
                            playsinline: 1,
                            rel: 0,
                            showinfo: 0
                        },
                        events: {
                            onReady: onPlayerReady,
                            onStateChange: onPlayerStateChange
                        }
                    });
                }

                let autoPlayOnReady = false;

                function onPlayerReady(event) {
                    playerReady.value = true;
                    event.target.setPlaybackQuality('hd720');
                    if (autoPlayOnReady) {
                        event.target.playVideo();
                    }
                }

                function onPlayerStateChange(event) {
                    isPlaying.value = event.data === YT.PlayerState.PLAYING;
                }

                function playVideo() {
                    if (player && playerReady.value) {
                        player.playVideo();
                    }
                }

                function pauseVideo() {
                    if (player && playerReady.value) {
                        player.pauseVideo();
                    }
                }

                function seekForward() {
                    if (player && playerReady.value) {
                        const currentTime = player.getCurrentTime();
                        player.seekTo(currentTime + 30, true);
                    }
                }

                function seekBackward() {
                    if (player && playerReady.value) {
                        const currentTime = player.getCurrentTime();
                        player.seekTo(Math.max(0, currentTime - 30), true);
                    }
                }

                // Generov√°n√≠ tratƒõ
                function generateTrack() {
                    const points = [];
                    let currentHeight = 0;
                    
                    // Generujeme segmenty s r≈Øznou d√©lkou podle variability
                    let segmentLength = Math.floor(30 + Math.random() * 90); // 30s-2min na segment
                    let targetHeight = 0;
                    let segmentProgress = segmentLength;
                    let startHeight = currentHeight;
                    
                    for (let i = 0; i < trackLength.value; i++) {
                        if (segmentProgress >= segmentLength) {
                            // Nov√Ω segment
                            segmentProgress = 0;
                            segmentLength = Math.floor(30 + Math.random() * 90); // Nov√° d√©lka segmentu
                            startHeight = currentHeight;
                            
                            // Nov√° c√≠lov√° v√Ω≈°ka - s pravdƒõpodobnost√≠ rovn√©ho √∫seku
                            if (Math.random() < 0.3) {
                                // 30% ≈°ance na rovn√Ω √∫sek (kolem nuly)
                                targetHeight = (Math.random() - 0.5) * 2;
                            } else {
                                // Kopec nebo sjezd
                                const intensity = roughness.value / 5; // 0.2 a≈æ 2
                                const change = (Math.random() - 0.4) * 20 * intensity;
                                targetHeight = currentHeight + change;
                                targetHeight = Math.max(-8, Math.min(15, targetHeight));
                            }
                        }
                        
                        // Plynul√° interpolace mezi startHeight a targetHeight
                        const t = segmentProgress / segmentLength;
                        // Pou≈æit√≠ hlad≈°√≠ quintic interpolace m√≠sto cubic
                        const smoothT = t * t * t * (t * (t * 6 - 15) + 10);
                        currentHeight = startHeight + (targetHeight - startHeight) * smoothT;
                        
                        points.push(currentHeight);
                        
                        segmentProgress++;
                    }
                    
                    // Gaussovsk√© vyhlazen√≠ tratƒõ (v√≠ce pr≈Øchod≈Ø, ≈°ir≈°√≠ okno)
                    for (let pass = 0; pass < 15; pass++) {
                        const temp = [...points];
                        for (let i = 2; i < points.length - 2; i++) {
                            // 5-bodov√Ω gaussovsk√Ω filtr pro hlad≈°√≠ p≈ôechody
                            temp[i] = (points[i - 2] + points[i - 1] * 4 + points[i] * 6 + points[i + 1] * 4 + points[i + 2]) / 16;
                        }
                        for (let i = 2; i < points.length - 2; i++) {
                            points[i] = temp[i];
                        }
                    }
                    
                    trackPoints.value = points;
                    cursorIndex.value = 0;
                }

                // Vykreslen√≠ tratƒõ
                function drawTrack() {
                    const canvas = trackCanvas.value;
                    if (!canvas) return;

                    const ctx = canvas.getContext('2d');
                    const rect = canvas.getBoundingClientRect();
                    
                    canvas.width = rect.width * 2;
                    canvas.height = rect.height * 2;
                    ctx.scale(2, 2);

                    const width = rect.width;
                    const height = rect.height;

                    ctx.clearRect(0, 0, width, height);

                    if (trackPoints.value.length === 0) return;

                    // Zoom a offset v√Ωpoƒçty
                    const visiblePoints = Math.floor(trackPoints.value.length / trackZoom.value);
                    const startIndex = Math.floor(trackOffset.value);
                    const endIndex = Math.min(startIndex + visiblePoints, trackPoints.value.length);
                    
                    // Automaticky centrovat na kurzor p≈ôi zoomu
                    if (trackZoom.value > 1) {
                        const idealStart = cursorIndex.value - visiblePoints / 2;
                        const newOffset = Math.max(0, Math.min(trackPoints.value.length - visiblePoints, idealStart));
                        if (Math.abs(trackOffset.value - newOffset) > visiblePoints * 0.4) {
                            trackOffset.value = newOffset;
                        }
                    }

                    const pointWidth = width / (visiblePoints - 1);

                    // Naj√≠t min/max pro normalizaci
                    const visibleData = trackPoints.value.slice(startIndex, endIndex);
                    const minValue = Math.min(...visibleData);
                    const maxValue = Math.max(...visibleData);
                    const range = Math.max(maxValue - minValue, 1);
                    
                    // Funkce pro p≈ôevod hodnoty na Y pozici
                    const valueToY = (value) => {
                        const normalized = (value - minValue) / range;
                        return height - (normalized * height * 0.8 + height * 0.1);
                    };

                    // Baseline (st≈ôed nebo nula)
                    const zeroY = minValue <= 0 && maxValue >= 0 ? valueToY(0) : height / 2;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(0, zeroY);
                    ctx.lineTo(width, zeroY);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Gradient pro v√Ωpl≈à
                    const gradient = ctx.createLinearGradient(0, 0, 0, height);
                    gradient.addColorStop(0, 'rgba(0, 212, 255, 0.3)');
                    gradient.addColorStop(1, 'rgba(0, 212, 255, 0.05)');

                    // V√Ωpl≈à pod k≈ôivkou
                    ctx.beginPath();
                    ctx.moveTo(0, height);
                    
                    for (let i = startIndex; i < endIndex; i++) {
                        const x = (i - startIndex) * pointWidth;
                        const y = valueToY(trackPoints.value[i]);
                        ctx.lineTo(x, y);
                    }
                    
                    ctx.lineTo(width, height);
                    ctx.closePath();
                    ctx.fillStyle = gradient;
                    ctx.fill();

                    // K≈ôivka profilu
                    ctx.strokeStyle = '#00d4ff';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();

                    for (let i = startIndex; i < endIndex; i++) {
                        const x = (i - startIndex) * pointWidth;
                        const y = valueToY(trackPoints.value[i]);
                        
                        if (i === startIndex) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();

                    // Aktu√°ln√≠ pozice (teƒçka) - pouze pokud je viditeln√°
                    if (cursorIndex.value >= startIndex && cursorIndex.value < endIndex) {
                        const cursorX = (cursorIndex.value - startIndex) * pointWidth;
                        const cursorY = valueToY(trackPoints.value[cursorIndex.value]);

                        // Svisl√° ƒç√°ra
                        ctx.strokeStyle = 'rgba(255, 159, 67, 0.5)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(cursorX, 0);
                        ctx.lineTo(cursorX, height);
                        ctx.stroke();

                        // Teƒçka
                        ctx.beginPath();
                        ctx.arc(cursorX, cursorY, 8, 0, Math.PI * 2);
                        ctx.fillStyle = '#ff9f43';
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // Vnit≈ôn√≠ teƒçka
                        ctx.beginPath();
                        ctx.arc(cursorX, cursorY, 4, 0, Math.PI * 2);
                        ctx.fillStyle = '#fff';
                        ctx.fill();
                    }
                }

                // Tick funkce (1√ó za sekundu)
                function tick() {
                    if (trackPoints.value.length === 0) return;

                    // Update RPM (st√°le n√°hodn√©)
                    rpm.value = 75;
                    rpmAnimating.value = true;
                    setTimeout(() => rpmAnimating.value = false, 200);

                    // Z√≠sk√°n√≠ aktu√°ln√≠ho bodu z grafu - gradient p≈ôes 10 sekund pro stabilnƒõj≈°√≠ hodnotu
                    const lookAhead = 10;
                    const currentPoint = trackPoints.value[cursorIndex.value];
                    const futureIndex = Math.min(cursorIndex.value + lookAhead, trackPoints.value.length - 1);
                    const futurePoint = trackPoints.value[futureIndex];

                    // Update Incline (stoup√°n√≠ = rozd√≠l v√Ω≈°ek p≈ôepoƒçten√Ω na %)
                    // Hodnoty v trackPoints jsou p≈ô√≠mo procenta stoup√°n√≠, tak≈æe bereme pr≈Ømƒõrn√Ω gradient
                    const slope = (futurePoint - currentPoint) / lookAhead * 40;
                    incline.value = Math.round(Math.max(minIncline.value, Math.min(maxIncline.value, slope)));
                    inclineAnimating.value = true;
                    setTimeout(() => inclineAnimating.value = false, 200);

                    // Update Load - realistick√Ω v√Ωpoƒçet odporu p≈ôi j√≠zdƒõ na kole
                    // 1. Valiv√Ω odpor (konstantn√≠ z√°klad ~3-5 na rovinƒõ)
                    const rollingResistance = 4;
                    
                    // 2. Odpor vzduchu (roste kvadraticky s rychlost√≠/RPM)
                    // Normalizace: 75 RPM = st≈ôedn√≠ rychlost, nad 90 RPM v√Ωraznƒõ roste
                    const normalizedRpm = rpm.value / 75;
                    const airResistance = Math.round(3 * normalizedRpm * normalizedRpm);
                    
                    // 3. Gravitaƒçn√≠ slo≈æka (stoup√°n√≠ m√° vƒõt≈°√≠ vliv ne≈æ sjezd)
                    // Stoup√°n√≠: ka≈æd√© 1% = cca +2 z√°tƒõ≈æe
                    // Sjezd: ka≈æd√© 1% = cca -1 z√°tƒõ≈æe (brzdƒõno valiv√Ωm odporem)
                    const gravityLoad = incline.value > 0 
                        ? incline.value * 2 
                        : incline.value * 0.8;
                    
                    // Celkov√° z√°tƒõ≈æ = souƒçet v≈°ech slo≈æek + ruƒçn√≠ korekce
                    const baseLoad = Math.round(rollingResistance + airResistance + gravityLoad);
                    load.value = Math.max(0, Math.min(30, baseLoad + loadOffset.value));
                    loadAnimating.value = true;
                    setTimeout(() => loadAnimating.value = false, 200);

                    // Posun kurzoru
                    cursorIndex.value = (cursorIndex.value + 1) % trackPoints.value.length;
                    
                    // P≈ôekreslit canvas
                    drawTrack();
                }

                // Reset hodnot
                function resetValues() {
                    rpm.value = 75;
                    incline.value = 0;
                    load.value = 15;
                    cursorIndex.value = 0;
                    drawTrack();
                }

                // Watch pro zmƒõny nastaven√≠
                watch([trackDuration, roughness], () => {
                    generateTrack();
                });

                watch(trackPoints, () => {
                    nextTick(() => drawTrack());
                }, { deep: true });

                // Lifecycle
                onMounted(() => {
                    // Naƒçten√≠ video historie
                    loadVideoHistory();

                    // Naƒçten√≠ YouTube IFrame API
                    const tag = document.createElement('script');
                    tag.src = 'https://www.youtube.com/iframe_api';
                    const firstScript = document.getElementsByTagName('script')[0];
                    firstScript.parentNode.insertBefore(tag, firstScript);

                    window.onYouTubeIframeAPIReady = () => {
                        console.log('YouTube API Ready');
                        // Naƒçten√≠ posledn√≠ho videa
                        const lastVideoId = localStorage.getItem('lastVideoId');
                        if (lastVideoId) {
                            videoId.value = lastVideoId;
                            initPlayer();
                        }
                    };

                    // Generov√°n√≠ poƒç√°teƒçn√≠ tratƒõ
                    generateTrack();

                    // Spu≈°tƒõn√≠ intervalu
                    tickInterval = setInterval(tick, 1000);

                    // Resize handler
                    window.addEventListener('resize', drawTrack);

                    // Poƒç√°teƒçn√≠ vykreslen√≠
                    nextTick(() => {
                        drawTrack();
                    });
                });

                onBeforeUnmount(() => {
                    if (tickInterval) {
                        clearInterval(tickInterval);
                    }
                    if (player) {
                        player.destroy();
                    }
                    window.removeEventListener('resize', drawTrack);
                });

                return {
                    // YouTube
                    youtubeUrl,
                    videoId,
                    playerReady,
                    isPlaying,
                    errorMessage,
                    loadVideo,
                    playVideo,
                    pauseVideo,
                    seekForward,
                    seekBackward,
                    videoHistory,
                    loadFromHistory,
                    deleteFromHistory,
                    
                    // Stats
                    rpm,
                    incline,
                    load,
                    loadOffset,
                    increaseLoad,
                    decreaseLoad,
                    rpmAnimating,
                    inclineAnimating,
                    loadAnimating,
                    
                    // Settings
                    minIncline,
                    maxIncline,
                    showSettings,
                    selectedDuration,
                    trackDuration,
                    onDurationChange,
                    roughness,
                    
                    // Track
                    showTrack,
                    trackPoints,
                    cursorIndex,
                    trackCanvas,
                    trackZoom,
                    zoomIn,
                    zoomOut,
                    scrollTrack,
                    seekToPosition,
                    generateTrack,
                    resetValues,
                    formatTime
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
